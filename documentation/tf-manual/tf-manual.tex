%** File: documentation/tf-manual/tf-manual.tex 
%** Contains: The Task Formalism (TF) Manual for the O-Plan system
%** Author: Austin Tate (bat@aiai)
%** Created: Thu Jun 30 11:08:34 1994
%** Updated: Wed Jan 29 17:25:26 1997 by Jeff Dalton
%** Release Version: 2.3
%** Copyright: (c) 1994, AIAI, University of Edinburgh
%** This material may be reproduced by or for the U.S. Government pursuant
%** to the copyright license under the clause at DFARS 252.227-7032
%** (June 1975) -- Rights in Technical Data and Computer Software (Foreign).

%** use the following commands to produce the TF Manual:
%** latex tf-manual; index tf-manual; latex tf-manual

%** Convert to PostScript (at AIAI) with:
%**    dvips  -f -Pexport < tf-manual.dvi > tf-manual.ps

%** ASSUMES LATEX command is run from within
%** documentation/tf-manual as we use ../<file> for style file

%** to do: introduce a single syntax term for {resource <resource name> ... }

\documentstyle [11pt,../oplan-doc]{article}
\projectdocument{3.1}{Task Formalism Manual}
\created{Austin Tate}{January 16, 1992}
\lastaltered{Jeff Dalton}{January 6, 1997}{10:00}

%** To ease giving <name> forms - use thus \M{name}, "M" for "meta"

\newcommand{\M}[1]{{$\langle$#1$\rangle$}}

% \newcommand{\bnf}[1]{{$<${\tt #1}$>$}}

\parskip=6pt

\makeindex

\begin{document}

\TitlePage
\Headers

\begin{center}
{\Large\bf IMPORTANT NOTE}
\end{center}

{\large This Task Formalism Manual presents a comprehensive view of a language
for describing planning domains, activities, processes, tasks and plans.
It acts as a design focus for work on the O-Plan project and research
into planning domain modelling.

The current implementation of the O-Plan planner does not accept all of
the Task Formalism constructs documented here.  A list of unsupported
features and features under investigation is given in section
\ref{current-implementation}.
}
\newpage

\tableofcontents

\opsection{Introduction to Task Formalism}

Domain representation in planning attempts to capture the detailed description
of permissible actions or operations within an application area, including
information about the effects of actions, conditions on the use of actions,
and how such conditions should be satisfied.  The need to describe
such a wide range of information has led to the specification and development
of a high level action description language called Task Formalism, or more
conveniently {\sc tf}. {\sc tf} originated in the Nonlin planning system but
has been refined and extended for action descriptions within the O-Plan
Planning System being developed at {\sc aiai}.

{\sc tf} is {\em not} intended as the normal mode of interaction with the user
describing a domain.  It is intended as an {\em intermediate language} which
fits between a supportive user interface and the planner.  {\sc tf} can be
considered to be the target language for a helpful domain writer's support
tool.  However, in the present release of the O-Plan system, it is necessary
to use the {\sc tf} language directly.  {\sc tf} has also been designed to
allow a useful level of compile time checking to be performed.

{\sc tf} is used to give an overall hierarchical description of an application
area by specifying the possible activities within the application domain and 
describing how those activities can be ``expanded'' into sets of sub-activities
with ordering contraints imposed.  Plans are generated by choosing suitable
expansions for activities in the plan (i.e. refining those activities) and
including the sets of more detailed sub-activities described by the chosen
expansions.  Ordering constraints are then satisfied to ensure that asserted
effects of some actions satisfy, and continue to satisfy, conditions on the
use of other actions.  Other constraints, such as a time window for the action
and restrictions on resource usage, are also included in the descriptions.
These descriptions of actions form the main structure within {\sc tf}---the
{\bf schema}.  Schemas are also used in a completely uniform manner to
describe {\bf tasks} set to the planning system, in the same formalism.
Other {\sc tf} structures hold global information of various sorts and
heuristic information about preferences for choices to be made during
planning.
\index{{\bf schema}}
\index{{\bf tasks}}

The purpose of this manual is to introduce the potential {\sc tf} writer to
the constructs of the language in order to describe application domains for
the O-Plan planning system.  {\sc tf}, like high level computer languages, is
compiled by the {\sc tf} Compiler into an internal data structure representing
the Domain Information.  The Compiler does some error checking, but it is
advisable to have a thorough understanding of {\sc tf} before starting out.

The {\sc tf} descriptions included below are presented in a mixed
reference/rationale form where the specification of {\sc tf} structures are
associated with explanatory notes.

{\sc tf} is still the subject of research and development.  There is no
guarantee that forward compatibility of any {\sc tf} form or component will be
preserved across new releases of O-Plan.  This manual includes an extensive
domain description language which goes beyond the specific features that
can be supported by the current implementation of O-Plan.  Section
\ref{current-implementation} describes the current implementation in terms of
unsupported features and features which are anticipated for the future.

\opsection{Hierarchical AI Planning Systems} 
\index{hierarchical planning}

Many knowledge-based planners---including the O-Plan Planning Agent---perform
a similar procedure to develop a plan.  The process is summarised in Figure
\ref{f-plan-hier}.

\begin{figure}[htb]
\vspace{9cm}
\special{psfile="../shared/shared-fig-plan-hier.ps"}
\caption{Outline of the operation of an AI Planner}
\label{f-plan-hier}
\end{figure}

Figure \ref{f-plan-hier} is a simplified overview of a ``Hierarchical
non-linear AI planner''.  The three parts show:

\begin{description}

\item[a)] Based on a hierarchical representation of the plan, a task in
the form of a skeleton plan or a set of requirements can be given and
expanded out to greater levels of detail. 

\item[b)] The planner searches through alternative methods of expanding
high level plans to lower level ones (and alternative means of
satisfying conditions, choosing objects, etc).  Interactions between
solutions to different parts of the plan are detected and corrected. 

\item[c)] At each level, the plan is represented as a network of nodes
in a form that allows the use of knowledge about the problem (such as
time and resource constraints) to restrict the search for a solution. 

\end{description}

\clearpage

\begin{figure}[htb]
\input{../shared/shared-fig-plan-expand.tex}
\caption{Expanding a step of the plan}
\label{f-plan-expand}
\end{figure}

Part (b) is often called ``expanding'' the plan.  As shown in figure
\ref{f-plan-expand}, some high level representation of a step in the
plan is selected and a more detailed method of carrying it out is found
in a ``library'' of such activity breakdowns (these are termed {\em
schemas}).  The expansion is then inserted into the plan and any
unresolved problems (such as unsatisfied conditions, actions needing
further expansion, resource requirements, etc) are noted. 

\clearpage

\opsection{Some Key Concepts}

\subsection{Actions and Events}
\index{actions} \index{events} \index{agents} \index{primitives}

Planning takes place in an environment where certain things are under the
explicit control of one or more {\em agents} responsible for completing one or
more {\em tasks} in the domain.

{\em Actions} are the activities which can be performed under the control
of the agents and which can alter the environment in which the agents
perform their tasks.

{\em Events} are those activities outwith the explicit control of the agents.

Actions and events can be described at a number of levels of detail in a
hierarchical fashion by being shown to be composed of a number of sub-actions
or sub-events ordered in some given way.  {\em Primitive} actions and events
cannot be further decomposed.

\subsection{Schemas}
\index{schemas} \index{schemas, normal} \index{normal schemas}
\index{schemas, action} \index{action schemas}
\index{schemas, process} \index{process schemas}
\index{schemas, meta} \index{meta-schemas}

Schemas are used to describe actions and events and where applicable
their decomposition to a more detailed level of description.  There are
a number of different types of schema: normal (or action) schemas,
process schemas, task schemas and meta-schemas.

A normal (action) schema describes an action under the deliberate control of
the plan.  A process schema describes an event or process comprising several
linked events which is outwith the direct control of the agent (though actions
performed by the agent may result in such events or processes being
triggered).  A task schema describes a task which the planner is being asked
to perform and may describe the environment in which the task is to take place
(in terms of the world model and the known events that will occur in it).

A meta-schema is a simple means to allow for families of similar schemas of
any of the three types above to be described.  Meta-schemas are used
at {\sc tf} compile time.

A schema can be pictured of as a triangle showing two ways in which the schema
can be utilised.  One, pointing from the top of the triangle, relates to its
use as a means of refining, decomposing or expanding an action or event to a
lower level of detail.  The right hand (output) side relates to its possible
use to provide an effect to satisfy a condition (or to provide additional
resources or authorities required for use in a plan).  The third left hand
(input) side of this triangle is the applicability conditions for the schema
(or the resources or authority it requires).


\begin{center}
\input{../shared/shared-fig-schema-triangle.tex}
\end{center}

\subsection{Authority}
\index{authority}

The O-Plan planner is intended to operate in a distributed command, planning
and execution environment. In such an environment, the authority provided to a
planner to create a plan or to modify it, and to an execution agent to allow
execution or adaptation of a specific chosen plan, needs to be made clear.

O-Plan currently supports only a simple implementation of authority
management.  However, the basis of a more sophisticated scheme is
allowed for with the following:

\begin{itemize}

\item
\index{plan, options} \index{options of plan}
the notion of separate {\em plan options} which are individually
specified task requirements, plan environments and plan elaborations.  The Task
Assignment agent can create as many as required.  The plan options may contain
the same task\footnote{Multiple conjunctive tasks specified together is
also possible.} with different search options or may contain a different
task and environmental assumptions.  It is possible to have only one plan
option as the minimum\footnote{Plan options may be established and explicitly
switched between by the Task Assignment agent.}.

\item
\index{plan, phases} \index{phases of plan}
the notion of {\em plan phases}.  These are
individually provided actions or events stated explicitly in the top level
task description given by the Task Assignment agent.  Greater precision
of authority management is possible by specifying more explicit phases at the
task level.  It is possible to have only one ``phase'' in the task as the
minimum\footnote{In fact any sub-component of any task schema or other schema
included by task expansion in a plan can be referred to as a ``phase''
within the O-Plan planner agent.  This can be done by referring to
its node number.}.

\item
\index{plan, levels} \index{levels of plan}
the notion of {\em plan levels}.   Greater precision
of authority management is possible by specifying more explicit levels in
the domain Task Formalism ({\sc tf}). It is possible to have only one ``level''
in the domain as the minimum.

\item for each ``phase'', planning will only be done down to an authorised
``level'' at which point planning will suspend leaving appropriate agenda
entries until deeper planning authorisation is given.

\item execution will be separately authorised for each ``phase''.

\end{itemize}

The planner agent will only need to be able to refer to {\em numbers\/} for
plan options, phases and levels.  Domain related names that are meaningful
to the user may be associated with these numbers through the Task Assignment
agent.

\subsection{Effects and Conditions}
\index{effects}
\index{conditions}

At the heart of the O-Plan plan representation for effects and conditions
are the {\sc tome} (Table Of Multiple Effects) and {\sc gost} (GOal
STructure)---tables to record all effects generated by actions in
the plan, the conditions satisfied at points in the plan, and the
intentions behind the ways in which conditions have been achieved.  The
{\sc gost} is the means by which the scope of an effect (there could be
several alternative such effects) which satisfies a condition can be
recorded and used to protect against the introduction of interacting
effects.  In a final valid plan all conditions introduced during planning
are required to have been satisfied and maintained over the required
period, hence there will be a valid {\sc gost} entry for each condition
encountered.

Conditions are one of the most elaborate of all {\sc tf} statements due
to the variety of condition types identified as being useful in
O-Plan.  The main types are:

\begin{description}

\item[only\_use\_if]
\index{{\bf only\_use\_if}}
\index{only\_use\_if condition}
\index{conditions, only\_use\_if}
A filter on the relevance of the schema based on a statement
in the environment which it is not anticipated will be altered
during the required range.

Normally used to filter out non-applicable schemas.

In the Nonlin planner, these were called {\bf usewhen} or
{\bf holds} conditions.
\index{conditions, usewhen} \index{usewhen condition}
\index{conditions, holds} \index{{\bf holds condition}}

\item[only\_use\_for\_query]
\index{{\bf only\_use\_for\_query}}
\index{only\_use\_for\_query condition}
\index{conditions, only\_use\_for\_query}
A condition anticipated as being satisfied in the environment.

Normally used to bind variables appearing in the condition.

\item[supervised]
\index{{\bf supervised}}
\index{supervised condition}
\index{conditions, supervised}
A condition established by (one or more alternative nominated)
substep(s) of the schema's decomposition.

Normally used to protect conditions across time intervals within
a schema.

\item[unsupervised]
\index{{\bf unsupervised}}
\index{unsupervised condition}
\index{conditions, unsupervised}
A condition which is anticipated as being established elsewhere in
a plan in which this schema is used.

Normally used to order steps in a plan to meet sequencing requirements.

\item[achieve]
\index{{\bf achieve}}
\index{achieve condition}
\index{conditions, achieve}
A condition which may be satisfied by any means available to
the planner (including adding new plan structure).

\item[compute]
\index{{\bf compute}}
\index{compute condition}
\index{conditions, compute}
These conditions provide the {\em O-Plan External System Interface}.  They
are not conditions satisfiable directly from effects within a plan.  A {\bf
compute} condition describes a requirement which can be satisfied using
information from an external system (or database or user).

\end{description}

Other condition types can be identified but the ones above have been found to
be useful ways to extract knowledge from a domain writer in a form that can be
used to restrict search in an AI planner.  The control of planner search via
condition types is worthy of a serious study in its own right, and could form
an ideal Ph.D. topic.

Condition typing allows information to be kept about when, how and why a
condition present in the plan has been satisfied and the way it is to be
treated if the condition cannot be maintained.  However, use of this
information itself will almost certainly commit the planner to prune some of
the potential search space thereby losing completeness of search if the {\sc
tf} writer uses an inappropriate condition type.  Unfortunately this puts a
burden on the domain writer and can make domain writing a difficult job.

Condition typing helps direct the planning process, but it also requires the
domain {\sc tf} writer to structure the hierarchy of the tasks or actions more
clearly (usually using separate {\em levels}).  It forces checks to be made on
processes or actions which should communicate with others to ensure that they
actually do advertise their results through a common vocabulary.

\subsection{Resources}
\index{resources}
\index{resource types}

The types of resource used in a plan can be classified as shown here.

\input{../shared/shared-fig-resources.tex}

\begin{description}

\item [consumable\_strictly:]
\index{resource types, consumable\_strictly}
\index{{\bf consumable\_strictly}}
A set amount of the resource is available and cannot be topped up.

\item [consumable\_producible\_by\_agent:]
\index{resource types, consumable\_producible\_by\_agent}
\index{{\bf consumable\_producible\_by\_agent}}
The resource can be topped up from actions for agents under the control of the
plan.

\item [consumable\_producible\_outwith\_agent:]
\index{resource types, consumable\_producible\_outwith\_agent}
\index{{\bf consumable\_producible\_outwith\_agent}}
This resource type is similar to consumable\_producible\_by\_agent except
that extra resource is only obtained via an off-line process such as a
delivery rather than via actions of agents under the control of the plan.

\item [consumable\_producible\_by\_and\_outwith\_agent:]
\index{resource types, consumable\_producible\_by\_and\_outwith\_agent}
\index{{\bf consumable\_producible\_by\_and\_outwith\_agent}}
This resource is a combination of the two above.  Resources can be produced
both by agent actions and by off-line processes.

\item [reusable\_non\_sharable:]
\index{resource types, reusable\_non\_sharable}
\index{{\bf reusable\_non\_sharable}}
The resource is allocated from a ``central pool'' in unit amounts and when the
resource is finished being used it is then deallocated back to the pool.  For
example workman, robots, lorries, etc.

\item [reusable\_sharable\_independently:]
\index{resource types, reusable\_sharable\_independently}
\index{{\bf reusable\_sharable\_independently}}
The resource can be shared without coordination to specific time periods,
e.g. spaces in a car park.

\item [sharable\_synchronously:]
\index{resource types, sharable\_synchronously}
\index{{\bf sharable\_synchronously}}
The resource is shared for a specific time, e.g.  capacity in a particular
journey of a ship or cargo plane.

\end{description}

\subsection{Patterns}
\index{patterns}

A \M{pattern} is a {\sc tf} component used throughout the Task Formalism.  A
\M{pattern} can be a constant name beginning with a letter and followed by
alphanumerical characters and one or two other permitted characters (e.g.
abc, part\_32), a number (e.g. 3, 5678, 3.142), or several of these
things surrounded by the braces \{ and \} to any depth (e.g. \{on a b\}, \{30
10 60\}, \{colour \{camera\_1 filter\_3\}\}), or set brackets ( and )
to any depth (e.g. (a (b c) d)).  These are all {\em fully
instantiated} \M{pattern}s.

A \M{pattern} may also contain
variables which have the form ?\M{name}, e.g. ?colour.  Such patterns
containing variables are often used to state the conditions and
effects of actions in the domain.

A \M{pattern} can also represent a {\em pattern specification} by giving a
template of pattern forms that can match it.  All match constraint
specifications start with the character ``?''.  The general ``match anything''
specification is ??.  Other match constraints include ?\{{\bf not}
green\}, ?\{{\bf bound}\}, etc.
For example, \{on ?? ?\{{\bf not} table\}\} is a valid specification for
\{on a b\} but not for \{on a table\}.
\index{pattern specifications}
\index{match constraints}

\subsection{\M{pattern} = \M{value}}
\index{pattern = value} \index{P=V}
\index{\M{pattern} = \M{value}}

A basic building block within O-Plan is the  \M{pattern} = \M{value}
form which is used throughout O-Plan to record information of the form:

\begin{verbatim}
   function(param, ...) = value
\end{verbatim}
such as in effects and conditions.  An example is:
\begin{verbatim}
   {colour camera_1 filter_3} = red
\end{verbatim}
where the first {\em fixed} word on the left side of the = is the function and
subsequent entries on the left side are the parameters.  The value is usually
a single name or number, but can also be a general pattern where appropriate
(e.g. \{20 30 15\} to represent a 3-dimensional spatial coordinate).  The
\M{pattern} = \M{value} form can be fully instantiated as in the example
above or may contain match constraints as mentioned earlier.

\subsection{Min/Max Pairs for Time Windows and Resource Usage}
\index{time windows} \index{resource usage} \index{min/max pairs}

All time windows and resource usage specifications in O-Plan are maintained
as {\bf min/max} pairs, specifying the upper and lower bounds known at any
time.  Such bounds may be defined by symbolic expressions which can depend on
variables, but O-Plan maintains a numerical pair of bounds for all such
numerical values.  In fact, a third entry is associated with such numerical
bounds.  This third entry is a {\em projected} value (which could be a simple
number or a more complex function, data structure, etc.) used by the planner
for heuristic estimation, search control and other purposes.
\index{projected value}

Time windows play an important part in O-Plan in two ways.  Firstly,
as a means of recording time limits for the start and finish of an action,
for its duration and for delays between actions.  Secondly, during
the planning phase itself as a means of pruning the potential search
space if temporal validity is threatened.

\begin{center}
\setlength{\unitlength}{1mm}
\begin{picture}(100,90)
\put(50,82){\makebox(0,0){specification overall}}
\put(2,80){\makebox(0,0){0}}
\multiput(5,80)(2,0){10}{\line(1,0){1}}
\put(25,80){\line(1,0){50}}
\multiput(76,80)(2,0){10}{\line(1,0){1}}
\put(98,80){\makebox(0,0){$\infty$}}
\put(25,80){\vector(0,-1){10}}
\put(75,80){\vector(0,-1){10}}
\put(5,60){\line(1,0){15}}
\put(12,62){\makebox(0,0){invalid}}
\put(12,58){\makebox(0,0){range}}
\put(35,60){\line(1,0){30}}
\put(50,62){\makebox(0,0){valid}}
\put(50,58){\makebox(0,0){range}}
\put(80,60){\line(1,0){15}}
\put(88,62){\makebox(0,0){invalid}}
\put(88,58){\makebox(0,0){range}}
\put(15,45){\line(1,0){70}}
\put(50,47){\makebox(0,0){valid}}
\put(50,43){\makebox(0,0){range}}
\put(5,30){\line(1,0){60}}
\put(35,32){\makebox(0,0){valid}}
\put(35,28){\makebox(0,0){range}}
\put(35,15){\line(1,0){60}}
\put(65,17){\makebox(0,0){valid}}
\put(65,13){\makebox(0,0){range}}
\multiput(9,2)(2,0){3}{\line(1,0){1}}
\put(50,2){\makebox(0,0){range of sum of utilisation at node ends}}
\multiput(85,2)(2,0){3}{\line(1,0){1}}
\put(15,3){\vector(0,1){6}}
\put(85,3){\vector(0,1){6}}
\end{picture}
\end{center}

Similarly, resource usage specifications are used to ensure that resource
usage stays within the bounds indicated.  There are two types of resource
usage statements.  One gives a {\em specification} of the {\bf overall}
limitation on resource usage for a schema (over the total time that the
schema's expansion can span).  The other type describes actual resource {\em
utilisation} {\bf at} points in the expansion of a schema.  It must be
possible (within the restriction on the ranges in the actual resource usage
statements) for a point in the range of the sum of the resource usage
statements to be within the overall specification given.

\subsection{Notepad}
\index{notepad} \index{global information}

A {\em Notepad} is associated with a plan in order that {\em global}
information about the plan can be recorded on it.  Conditions can also be
stated with respect to the contents of the Notepad and schemas can be selected
to achieve entries on the Notepad.  Notepad effects are known as {\em Notes}.
Normally, effects are asserted at a specific point in the plan network and
conditions are stated as needing to be satisfied at specific points.  The
Notepad facility provides a means to record plan information which is not
specific to any component of the plan.

For example, notes can be used to record information about the strategy or
approach being adopted in the search for a solution, or it may be used to
record information about the choices being made.  A user may also use the
Notepad directly during plan generation when acting in the {\em Planner
User Role} -- the Knowledge Source KS\_USER normally allows Notes to be
recorded and the Notepad to be viewed.

O-Plan1 used the term {\em jotter} for the Notepad.
\index{{\bf jotter}}

\subsection{O-Plan External System Interface}
\index{external system interface} \index{conditions, compute}

The O-Plan External System Interface is provided via {\bf
compute} conditions in O-Plan schemas.  The external
system could be a data base system, a modelling package for the
application, a CAD system, a table look-up system or a special interface
to the user, for example.  The external system is called by a function
name and is passed parameters which are instantiated versions of the
schema variables referred to in the call expression.  The external
system can also be an O-Plan support routines.  One gives access to
the question answering routine which can query conditions at the point
in the plan where the compute condition is evaluated.  Another allows
Notepad entries to be changed. 

A protocol for the External System Interface allows the results to be returned
to the planner in a form that can be understood.  This allows none, one or
several alternative results to be returned along with optional dependency
statements on the continuing validity of the various results (in a form which
the planner can take responsibility to maintain).

New user-provided compute functions can be declared to the planner via a
{\bf compute\_conditions} statement in the {\sc tf} for a domain.  This
ensures that the planner knows how to call a compute condition and how to
deal with its results.

\opsection{Commented Examples}

Before covering the detail of {\sc tf} forms and syntax in this manual,
two examples will be presented here to give a flavour of the language.

\subsection{Blocks World}
\index{blocks world}
In this first example the single schema required to describe operations in a
simple blocks world is outlined. The world is simple because
there is no consideration given to block dimensions, alignment of blocks or to
the lifting mechanism. The only prerequisites are that a block has to be
clear before it can be moved and that its destination block is also clear (the
table is assumed to have clear space always). The single schema is called {\bf
puton} to reflect the lift-and-stack nature of the application.

In this particular application the schema is only used to satisfy {\bf
achieve} conditions through the use of (only\_use\_for\_)effects, hence the
expands pattern merely serves to describe the (primitive) action.  This schema
also illustrates the use of local schema variables.  These variables can be
instantiated by a number of means:

\begin{itemize}

\item
By use of the {\bf expands} or ({\bf only\_use\_for\_}){\bf effects} with
fully instantiated patterns.
\index{expands}
\index{only\_use\_for\_effects}

\item
By use of the {\bf only\_use\_for\_query} condition type. 
\index{only\_use\_for\_query}

\item
If the {\bf schema variables} are not fully
instantiated during the period of use of the schema then such variables
are converted to plan state (i.e. global) variables, to be handled later
by an appropriate knowledge source. 
\index{{\bf schema variables}}

\end{itemize}

\begin{verbatim}
always {cleartop table};

types objects = (a b c table),
      movable_objects = (a b c);

schema puton;
  vars ?x = ?{type movable_objects},
       ?y = ?{type objects},
       ?z = ?{type objects};
  vars_relations ?x /= ?y, ?y /= ?z, ?x /= ?z;
  expands {puton ?x ?y};                     ;;; the actual action name
  only_use_for_effects
              {on ?x ?y}    = true,
              {cleartop ?y} = false,         ;;; satisfy conditions in plan
              {on ?x ?z}    = false,
              {cleartop ?z} = true;
  conditions  only_use_for_query {on ?x ?z}, 
                   ;;; only_use_for_query is used to bind one or more
                   ;;; free variables conditions have value true
              achieve {cleartop ?y},         
              achieve {cleartop ?x};
end_schema;
\end{verbatim}

The above representation of the Blocks World domain can be used to generate
plans from tasks set within appropriate {\bf task} schemas.  Here is an
example which describes an initial world (as shown in the diagram) and a
final world in which Block A is on Block B which is on Block C.

\begin{verbatim}
task stack_ABC;
  nodes 1 start,
        2 finish;
  orderings 1 ---> 2;
  conditions achieve {on a b} at 2,
             achieve {on b c} at 2;
  effects {on c a} at 1,
          {on a table} at 1,
          {on b table} at 1,
          {cleartop c} at 1,
          {cleartop b} at 1;
end_task;

;;;                                            +---+
;;;                                            | A |
;;;      +---+                                 +---+
;;;      | C |              --------->         | B |     
;;;      +---+  +---+                          +---+
;;;      | A |  | B |                          | C |
;;; -----+---+--+---+-----                     +---+
;;;         TABLE
\end{verbatim}

\subsection{House Building}
\index{house building}

The second example shows more of the features of {\sc tf}, in particular the
use of {\em typed conditions} to reflect the ``sub-contractor'' nature of
individual schemas.  In particular, the schema actions correspond to the
activities performed by a possible contractor) and the schema conditions make
a statement about the level of commitment of that contractor to that
particular condition.  For example a supervised condition states categorically
that the same contractor will take responsibility for satisfying required
conditions on actions within the sub-plan, whereas unsupervised conditions
state that the responsibility lies elsewhere but is required to hold at the
appropriate time.

This example {\sc tf} also shows a couple of {\em time windows} statements and
{\em primitive} schemas, it introduces alternative schema expansion methods,
and it deliberately includes an alternative which fails to lead to a valid
plan.

\begin{verbatim}
task build_house;               ;;; top level task schema to initiate planning
  nodes 1 start,  
        2 finish,
        3 action {build house}; ;;; this action is refined by the schema below
  orderings 1 ---> 3, 3 ---> 2;      
end_task;

schema build;
  expands {build house};        ;;; this expands the top level action
  nodes     1 action {excavate and pour footers    },  ;;; some are primitive
            2 action {pour concrete foundations    },
            3 action {erect frame and roof         },
            4 action {lay brickwork                },
            5 action {finish roofing and flashing  },
            6 action {fasten gutters and downspouts},
            7 action {finish grading               },
            8 action {pour walks and landscape     },
            9 action {install services             },  ;;; some are not.
           10 action {decorate                     };
  orderings 1 ---> 2,  2 ---> 3,  3 ---> 4,  4 ---> 5,
            5 ---> 6,  6 ---> 7,  7 ---> 8;
  ;;; actions 9 & 10 are not ordered wrt other actions - they are in parallel
  conditions   supervised {footers poured        } at 2 from [1],
               supervised {foundations laid      } at 3 from [2],
               supervised {frame and roof erected} at 4 from [3],
               supervised {brickwork done        } at 5 from [4],
               supervised {roofing finished      } at 6 from [5],
               supervised {gutters etc fastened  } at 7 from [6],
             unsupervised {storm drains laid     } at 7,
               supervised {grading done          } at 8 from [7];
  ;;; note the unsupervised condition - its satisfaction is outwith
  ;;; the control of this schema but must still be satisfied
  time_windows between 1~11:30:00 and 1~14:30:00 at 2,
               between 1~12:00:00 and 1~14:00:00 at 3;
  ;;; time window examples for start times of actions 2 & 3
end_schema;
  
schema service_1;
  expands {install services};   ;;; one way of expanding {install services}
  only_use_for_effects {installed services 1};
  nodes     1 action {install drains           },
            2 action {lay storm drains         },
            3 action {install rough plumbing   },
            4 action {install finished plumbing},
            5 action {install rough wiring     },
            6 action {finish electrical work   },
            7 action {install kitchen equipment},
            8 action {install air conditioning };
  orderings 1 ---> 3,  3 ---> 4,  5 ---> 6,  3 ---> 7,  5 ---> 7;
  conditions   supervised {drains installed        } at 3 from [1],
               supervised {rough plumbing installed} at 4 from [3],
               supervised {rough wiring installed  } at 6 from [5],
               supervised {rough plumbing installed} at 7 from [3],
               supervised {rough wiring installed  } at 7 from [5],
             unsupervised {foundations laid        } at 1,
             unsupervised {foundations laid        } at 2,
             unsupervised {frame and roof erected  } at 5,
             unsupervised {frame and roof erected  } at 8,
             unsupervised {basement floor laid     } at 8,
             unsupervised {flooring finished       } at 4,
             unsupervised {flooring finished       } at 7,
             unsupervised {painted                 } at 6;
    ;;; As in the real world this sub-contractor relies heavily on others
    ;;; to prepare things beforehand - see the unsupervised conditions.
end_schema;
           
schema service_2;
  expands {install services};   ;;; another possible expansion
  only_use_for_effects {installed services 2};
  nodes     1 action {install drains           },
            2 action {install rough plumbing   },
            3 action {install finished plumbing},
            4 action {install rough wiring     },
            5 action {finish electrical work   },
            6 action {install kitchen equipment},
            7 action {install air conditioning };
  ;;; This sub-contractor fails to {lay storm drains}.
  ;;; This will lead to plan failure when this schema is used
  orderings 1 ---> 2,  2 ---> 3,  4 ---> 5,  2 ---> 6,  4 ---> 6;
  conditions   supervised {drains installed        } at 2 from [1],
               supervised {rough plumbing installed} at 3 from [2],
               supervised {rough wiring installed  } at 5 from [4],
               supervised {rough plumbing installed} at 6 from [2],
               supervised {rough wiring installed  } at 6 from [4],
             unsupervised {foundations laid        } at 1,
             unsupervised {frame and roof erected  } at 4,
             unsupervised {frame and roof erected  } at 7,
             unsupervised {basement floor laid     } at 7,
             unsupervised {flooring finished       } at 3,
             unsupervised {flooring finished       } at 6,
             unsupervised {painted                 } at 5;
  effects {wallpaper on} = false at 5;  ;;; an interaction check
  ;;; Effects can be asserted - this one strips wallpaper.
  ;;; Effects of this form can cause interactions to occur and plan steps
  ;;; to be linearised if a condition {wallpaper on} = true appears in, say,
  ;;; the decorate schema.
end_schema;
           
schema decor;
  expands {decorate};
  nodes     1 action {fasten plaster and plaster board},
            2 action {pour basement floor             },
            3 action {lay finished flooring           },
            4 action {finish carpentry                },
            5 action {sand and varnish floors         },
            6 action {paint                           };
  orderings  2 ---> 3,  3 ---> 4,  4 ---> 5,  1 ---> 3,  6 ---> 5;
  conditions unsupervised {rough plumbing installed   } at 1,
             unsupervised {rough wiring installed     } at 1,
             unsupervised {air conditioning installed } at 1,
             unsupervised {drains installed           } at 2,
             unsupervised {plumbing finished          } at 6,
             unsupervised {kitchen equipment installed} at 6,
               supervised {plastering finished        } at 3 from [1],
               supervised {basement floor laid        } at 3 from [2],
               supervised {flooring finished          } at 4 from [3],
               supervised {carpentry finished         } at 5 from [4],
               supervised {painted                    } at 5 from [6];
  time_windows between 1~11:30:00 and 1~14:30:00 at 2,
               between 1~12:00:00 and 1~14:00:00 at 3;
end_schema;

;;; Now for completeness a list of primitive actions. Primitives are
;;; defined as having no nodes list and must have an expands pattern.

schema excavate;
  expands {excavate and pour footers};
  only_use_for_effects {footers poured} = true;
end_schema;

schema pour_concrete;
  expands {pour concrete foundations};
  only_use_for_effects {foundations laid} = true;
end_schema;

schema erect_frame;
  expands {erect frame and roof};
  only_use_for_effects {frame and roof erected} = true;
end_schema;

schema brickwork;
  expands {lay brickwork};
  only_use_for_effects {brickwork done} = true;
end_schema;

schema finish_roofing;
  expands {finish roofing and flashing};
  only_use_for_effects {roofing finished} = true;
end_schema;

schema fasten_gutters;
  expands {fasten gutters and downspouts};
  only_use_for_effects {gutters etc fastened} = true;
end_schema;

schema finish_grading;
  expands {finish grading};
  only_use_for_effects {grading done} = true;
end_schema;

schema pour_walks;
  expands {pour walks and landscape};
  only_use_for_effects {landscaping done} = true;
end_schema;

schema install_drains;
  expands {install drains};
  only_use_for_effects {drains installed} = true;
end_schema;

schema lay_storm;
  expands {lay storm drains};
  only_use_for_effects {storm drains laid} = true;
end_schema;

schema rough_plumbing;
  expands {install rough plumbing};
  only_use_for_effects {rough plumbing installed} = true;
end_schema;

schema install_finished;
  expands {install finished plumbing};
  only_use_for_effects {plumbing finished} = true;
end_schema;

schema rough_wiring;
  expands {install rough wiring};
  only_use_for_effects {rough wiring installed} = true;
end_schema;

schema finish_electrical;
  expands {finish electrical work};
  only_use_for_effects {electrical work finished} = true;
end_schema;

schema install_kitchen;
  expands {install kitchen equipment};
  only_use_for_effects {kitchen equipment installed} = true;
end_schema;

schema install_air;
  expands {install air conditioning};
  only_use_for_effects {air conditioning installed} = true;
end_schema;

schema fasten_plaster;
  expands {fasten plaster and plaster board};
  only_use_for_effects {plastering finished } = true;
end_schema;

schema pour_basement;
  expands {pour basement floor};
  only_use_for_effects {basement floor laid } = true;
end_schema;

schema lay_flooring;
  expands {lay finished flooring};
  only_use_for_effects {flooring finished} = true;
end_schema;

schema finish_garden;
  expands {finish garden};
  only_use_for_effects {garden finished};
end_schema;

schema finish_carpentry;
  expands {finish carpentry};
  only_use_for_effects {carpentry finished} = true;
end_schema;

schema sand;
  expands {sand and varnish floors};
  only_use_for_effects {floors finished} = true;
end_schema;

schema paint;
  expands {paint};
  only_use_for_effects {painted} = true;
end_schema;
\end{verbatim}

\opsection{Conventions Used in the TF Description}
\index{conventions used in {\sc tf} description}
\index{TF, syntax conventions}

Some simple conventions used throughout deserve explanation before the
{\sc tf} language is defined:

\begin{description}

\item[Keywords]
Keywords used in {\sc tf} are written in {\bf bold} lettering for
highlighting purposes in the descriptions of statements.

\item[Components]
{\sc tf} components are surrounded by angle brackets ``\M{  }''.

\item[Options]
Optional words or phrases are surrounded by square brackets ``[  ]''.

\item[Choice]
If there is more than one possible representation for an expression then
the alternatives are separated by the vertical bar character ``$|$''.

\item[Repetition]
If a structure can be repeated indefinitely then this is indicated by three
dots ``...'' occurring directly under (i.e. aligned with) the beginning of
the structure to be repeated, or directly after the structure (on the same
line) when the meaning should be clear.\footnote{Note that if the structure
ends with a comma, the comma should still be treated as a {\em separator}.
That is, the comma should be written only to spearate instances of the
structure and should not be written after the last instance in a sequence.}

\item[Component Definition]
Following the definition of a {\sc tf} statement, a number of components may
be further defined.  This is indicated by following the name of the
component by ``::=''  and its definition.
\index{{\bf ::=}}

\item[Punctuation]
Use is made of two punctuation marks in {\sc tf} statement definitions, namely

\begin{enumerate}

\item ``{\bf ;}''
indicates the end of a statement (for example a condition list).

\item ``{\bf ,}''
is used as a list separator within statements.

\end{enumerate}

Neither is optional and their omission will cause an error when the
{\sc tf} is compiled.

The {\sc tf} Compiler requires ``white space'' to separate operators or
potential operators.  E.g. you can write ``$3+4$'' but not ``$3+-4$''.  For the
latter, you have to write ``$3 + -4$''.  However, single character parentheses,
braces and punctuation does not require surrounding white space.  When in
doubt add parentheses or white space.

\item[Comments]
Comments may be included anywhere in {\sc tf} descriptions
and are introduced by three semicolons ``{\bf ;;;}''
Everything following these in the line is treated as comment
and ignored by the {\sc tf} Compiler.
\index{{\bf ;;;}}.

\end{description}

\opsection{Component Definitions}

{\sc tf} forms are the basis for the {\sc tf} language and are defined in the
next section.  A number of commonly used {\em components} occur in several
of these forms.  For convenience, these are defined separately  in this
section.

\subsection{Basics}

The following defines some basic components used in many {\sc tf} forms.

\begin{verbatim}
   <atom> ::= <name> | <number>

   <name> ::= [<digit> ...] <letter_or_special> <name_body>

   <name_body> ::= [ <letter_or_special> | <digit> ]
                   ...

   <letter> ::= A | B | ... | Z | a | b | ... | z

   <letter_or_special> ::= <letter> | _ | %

   <text_string> ::= " [ <character> ... ] "
\end{verbatim}
\index{\M{atom}}
\index{\M{name}}
\index{\M{text\_string}}

Although a \M{name} can start with a digit, it must not be a \M{number}.

\begin{verbatim}
   <number> ::= <integer> | <float> | inf | infinity

   <integer> ::= [ <sign> ] <digits>

   <float> ::= [ <sign> ] <digits> [. <digits> ] [ <exponent> ]

   <digits> ::= <digit> ...

   <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

   <exponent> ::= <exponent_marker> [<sign>] <digits>

   <exponent_marker> ::= e | E

   <sign> ::= + | -
\end{verbatim}
\index{\M{number}}
\index{{\bf inf}}
\index{{\bf infinity}}

{\tt inf} $=$ {\tt infinity} $=$ $\infty$ is a number larger than any other.

\subsection{Patterns, Values, Variables and Match Constraints}
\index{patterns}
\index{values}
\index{variables}
\index{match constraints}

% /\/: Why is it <variable_name> below rather than <variable>?

\begin{verbatim}
   <pattern_component> ::= <atom> | <match_constraint> |
                           { <pattern_component> ... } |
                           ( <pattern_component> ... )
   
   <general_pattern> ::= { <pattern_component> ... }

   <pattern> ::= { <name> <pattern_component> ... }

   <value> ::= <pattern_component>

   <variable_name> ::= ?<name>

   <variable_restriction> ::= <match_constraint> | undef

   <match_constraint> ::=     ??
                            | ?<name>
                            | ?{bound}
                            | ?{type <type_name>}
                            | ?{not <pattern_component>}
                            | ?{or <pattern_component> ... }
                            | ?{and <pattern_component>  ... }
                            | ?{contains <pattern_component>}
                            | ?{has <function_name>
                                  [ <other_function_argument> ... ]
                                    <function_result> }
                            | ?{satisfies <predicate_name>
                                  [ <other_predicate_argument> ... ] }
 
   <function_name> | <predicate_name> ::= <name>
 
   <other_function_argument> ::= <parameter appropriate to function>

   <other_predicate_argument> ::= <parameter appropriate to predicate>
 
   <function_result> ::= <result appropriate to function>
 
   <sup_position> ::= <integer 1 to length of <pattern> given>
\end{verbatim}
\index{\M{function\_name}}
\index{\M{predicate\_name}}
\index{\M{other\_function\_argument}}
\index{\M{other\_predicate\_argument}}
\index{\M{function\_result}}
\index{{\bf has}}
\index{{\bf satisfies}}
\index{\M{pattern\_component}}
\index{\M{general\_pattern}}
\index{\M{pattern}}
\index{\M{value}}
\index{\M{variable\_name}}
\index{\M{variable\_restriction}}
\index{\M{match\_constraint}}
\index{\M{type\_name}}
\index{{\bf undef}}
\index{{\bf ??}}
\index{{\bf ?\M{name}}}
\index{{\bf bound}}
\index{{\bf type}}
\index{{\bf not}}
\index{{\bf or}}
\index{{\bf and}}
\index{{\bf contains}}

The special match restriction {\bf undef} is equivalent
to {\bf ??} and means that there is no restriction on
the item being matched.

% /\/: Is that true, about undef?

The other match restrictions have the following meaning:

\begin{itemize}

\item
\index{{\bf ?}\{{\bf bound}\}}
{\bf ?\{bound\}} matches items where any variables
referred to are fully instantiated.

\item
\index{{\bf ?}\{{\bf type \M{type\_name}}\}}
{\bf ?\{type \M{type\_name}\}}
matches items which are included in the set of names
declared by \M{type\_name}.

\item
\index{{\bf ?}\{{\bf not \M{parameter}}\}}
{\bf ?\{not \M{parameter} \}} matches anything that
does not match the parameter.

\item
\index{{\bf ?}\{{\bf or \M{parameter} ...}\}}
{\bf ?\{or \M{parameter} ... \}}  matches anything which matches one
of the parameters.

\item
\index{{\bf ?}\{{\bf and \M{parameter} ...}\}}
{\bf ?\{and \M{parameter} ... \}} matches anything which matches
all of the parameters.

\item
\index{{\bf ?}\{{\bf contains \M{set}}\}}
{\bf ?\{contains \M{set} \}} matches anything which matches
one member of the set.

% /\/: That makes "contains" sound backwards.  Contains ought to be
% saying that the item being matched contains some specified element,
% not that the item is _contained in_ some set.

\item
\index{{\bf ?}\{{\bf has \M{function\_name} ... \}}}
{\bf ?\{has \M{function\_name} [\M{other\_function\_argument} ... ]
\M{function\_result}\}}
matches anything (the \M{matched\_item}) for which lisp can evaluate

(\M{function\_name} \M{matched\_item}
[\M{other\_function\_argument} ... ] )

and where the result of this call matches the given
\M{function\_result}.  If Lisp cannot evaluate the function on the given
arguments, then the result is no match.

An example of the use of {\bf has} is {\bf ?\{has} length 3{\bf \}}
which can be used to check that a matching item is a list with three
elements at its top level.

\item
\index{{\bf ?}\{{\bf satisfies \M{predicate\_name} ... \}}}
{\bf ?\{has \M{predicate\_name} [\M{other\_predicate\_argument} ... ]\}}
matches anything (the \M{matched\_item}) for which lisp can evaluate

(\M{predicate\_name} \M{matched\_item}
[\M{other\_predicate\_argument} ... ] )

and return {\bf t} (true).  If Lisp cannot evaluate the predicate on the given
arguments, then the result is no match.

{\bf satisfies} is an easier way to specify boolean match requirements
than {\bf has}, but otherwise is very similar.

An example of the use of {\bf satisfies} is {\bf ?\{satisfies} > 50{\bf \}}
which can be used to check that a matching item is greater than 50.

\end{itemize}

\subsection{Expressions}
\index{expressions}

Expressions (possibly containing variables whose values
will only become apparent when a form is used within the planner)
may be given wherever a number appears in suitable {\sc tf} forms.
This facility is not currently supported.

\begin{verbatim}
   <expression> ::=    [ <plus_or_minus> ] <operand>
                    |  <expression> <operator> <expression>
                    |  ( <expression> )

   <plus_or_minus> ::= + | -

   <operator> ::= <plus_or_minus> | * | /

   <operand> ::= <number> | <variable_name>
\end{verbatim}
\index{\M{expression}} \index{\M{plus\_or\_minus}}
\index{\M{operator}} \index{\M{operand}} 

Operator precedence is $*$ and $/$ take precedence over $+$ and $-$.  No
other precedence should be assumed.  It is recommended that parentheses
are used to make the meaning of the expression clear where necessary.

\subsection{Sets}
\index{set}

Sets are surrounded by parentheses ``(`` and ``)''.  They may
be sets of names, or may be sets of more general items which
includes numbers, patterns, etc.

\begin{verbatim}
   <set> ::= <name_set> | <general_set>

   <name_set> ::= ( <name> ... )

   <general_set> ::= ( <general_pattern> ... )
\end{verbatim}
\index{\M{set}} \index{\M{name\_set}} \index{\M{general\_set}}

It is possible to do matching on a member of a set with the ?\{{\bf
contains} \M{set} \} match constraint.  It is anticipated that more
comprehensive handling and matching for sets will be added in future. 

\subsection{Nodes}
\index{nodes}
Nodes are introduced in schemas to show a decomposition of a higher
level task, action or process.  Nodes have a type.

\begin{verbatim}
   <node_type> ::= <action_or_event> | <dummy_node_type>

   <action_or_event> ::= action | event

   <dummy_node_type> ::= dummy | start | finish
\end{verbatim}

\index{{\bf action}}
\index{{\bf event}}
\index{{\bf dummy}}
\index{{\bf start}}
\index{{\bf finish}}
\index{\M{dummy\_node\_type}}
\index{\M{action\_or\_event}}
\index{\M{node\_type}}

\subsection{Specifications of Node Numbers, Node Ends and Time Points}
\index{node numbers} \index{node ends} \index{time points}

\begin{verbatim}
   <node_number> ::= <integer>

   <node_end> ::=  [ <end> ] <node_number>  |  [ <end> ] <self>

   <end> ::= begin_of | end_of

   <at_spec> ::= at <node_end>
\end{verbatim}
\index{\M{node\_number}}
\index{\M{node\_end}}
\index{{\bf begin\_of}}
\index{{\bf end\_of}}
\index{\M{end}}
\index{\M{at\_spec}}
\index{{\bf self}}
\index{{\bf at} \M{node\_end}}

A \M{node\_end} can be given for any time point referred to in {\sc tf}.
The default ``end'' depends on the context of use -- see the individual notes
on {\sc tf} forms for the default in each case.  {\bf at self} (possibly with
an optional {\tt \M{end}}) may be used to specify that the time point is the
whole schema expansion or the whole primitive being defined.

\subsection{Numerical Bounds}
\index{numerical bounds}

\begin{verbatim}
   <min_max_spec> ::=     <expression> .. <expression>
                       |  min <expression> .. max <expression>
                       |  min <expression>
                       |  >= <expression>
                       |  max <expression>
                       |  <= <expression>
                       |  <expression>
                       |  no[ne]
                       |  some
                       |  ( <min_max_spec> )
\end{verbatim}
\index{\M{min\_max\_spec}}
\index{{\bf min}}
\index{{\bf max}}
\index{{\bf none}}
\index{{\bf no}}
\index{{\bf some}}

All numerical ranges map to a minimum and maximum pair as follows:

\begin{center} 
\begin{tabular}{|l|c|c|}
\hline
&min&max \\
\hline
x&x&x \\
x..y&x&y \\
{\bf min} x .. {\bf max} y&x&y \\
{\bf min} x&x&infinity \\
$>$=x&x&infinity \\
{\bf max} y&0&y \\
$<$=y&0&y \\
{\bf no} or {\bf none}&0&0 \\
{\bf some}&0&infinity \\
\hline
\end{tabular}
\end{center}

Depending on the context, the default is usually {\bf some}
(e.g. for resource specifications given with the {\bf overall}
descriptor), or {\bf none} (e.g. where
resource usage specifications are given {\bf at} node ends). 

\subsection{Time Specifications}
\index{time specifications}

\begin{verbatim}
   <time_spec> ::=    <expression>  [ <time_units> ]
                    | <hours> : <minutes> [ : <seconds> ]
                    | <days> ~ <hours> : <minutes> [ : <seconds>]

   <days> | <hours> | <minutes> | <seconds> ::= <integer>

   <time_units> ::=    seconds
                    |  minutes
                    |  hours
                    |  days

   <time_bounds_spec> ::=  <time_bounds_pair> [ with <time_preference> ]
                        |  ( <time_bounds_pair> [ with <time_preference> ] )

   <time_bounds_pair> ::=  [ occurs_at ] <time_spec>
                        |  [ et = ]       <time_spec> [ .. ]
                           [ lt = ]       <time_spec>
                        |  [ between ] [ et = ] <time_spec>
                           [ and | .. ] [ lt = ] <time_spec>
                        |  after <time_spec>
                        |  > <time_spec>
                        |  before <time_spec>
                        |  < <time_spec>

   <time_preference> ::=  ideal = <time_spec>
                                   other preferences are being considered
\end{verbatim}
\index{\M{time\_spec}}
\index{\M{time\_units}}
\index{\M{days}}
\index{\M{time\_bounds\_spec}}
\index{\M{time\_bounds\_pair}}
\index{\M{time\_preference}}
\index{{\bf ideal}}
\index{{\bf after}}
\index{{\bf before}}
\index{{\bf et =}}
\index{{\bf lt =}}
\index{{\bf occurs\_at}}
\index{{\bf between}}
\index{{\bf inf}}
\index{{\bf infinity}}

The specifications of \M{days}, \M{hours}, etc.  are integer.  All time
specifications map to a number of time units relative to some absolute zero
time: 0$\sim$0:0:0.  In the absence of an explicit specification of the
\M{time\_units} seconds is the default.  The special symbols {\bf inf} and
{\bf infinity} may be used and map to a number larger than any other number.

All time window specifications map onto the same form of a minimum/maximum
pair as shown in the table below.

\begin{center} 
\begin{tabular}{|l|c|c|c|}
\hline
&est/min&lst/max \\
\hline
{\bf occurs\_at} t&t&t \\
t&t&t \\
{\bf et}=t1..lt=t2&t1&t2 \\
t1..t2&t1&t2 \\
{\bf et}=t1..lt=t2&t1&t2 \\
{\bf between} t1 {\bf and} t2&t1&t2 \\
{\bf after} t&t&infinity \\
$>$ t&t&infinity \\
{\bf before} t&0&t \\
$<$ t&0&t \\
{\em default time specification}&0&infinity \\
\hline
\end{tabular}
\end{center}

The {\bf initial\_time} specification for the plan will serve to
assist the planner to improve the lower time bound specifications when the
planner operates. 
\index{{\bf initial\_time}}

\subsection{Resource Specifications}
\index{resource specifications}

\begin{verbatim}
   <resource_usage_spec> ::= <resource_usage_keyword>
                             { resource <resource_name>
                                  [ <resource_qualifier> ... ] }
                             = <resource_range>
                             [ <resource_unit> ]
                             [ <resource_scope_spec> ]

   <resource_name> ::= <name>

   <resource_qualifier> ::= <name>

   <resource_range> ::= unlimited | <min_max_spec>
\end{verbatim}
\index{\M{resource\_usage\_spec}}
\index{\M{resource\_name}}
\index{\M{resource\_qualifier}}
\index{\M{resource\_range}}

\begin{verbatim}
   <resource_unit> ::= <resource_unit_name> | <resource_unit_synonym>

   <resource_unit_name> ::= <name>

   <resource_unit_synonym> ::= <name>
\end{verbatim}

\begin{flushright}
May be used for plural form, etc
\end{flushright}

\begin{verbatim}
   <resource_scope_spec> ::=  overall | <at_spec>
\end{verbatim}

\begin{flushright}
Default is {\bf overall} \\

If the {\bf at} option is given without an \M{end} being specified \\
for the given node, then the default is that specified by the \\
\M{resource\_usage\_node\_end} in the {\bf defaults} {\sc tf} statement.
\end{flushright}

\begin{verbatim}
   <resource_usage_keyword> ::=   sets        | * |
                                  allocates   | - |
                                  deallocates | + |
                                  produces    | ^ |
                                  consumes    | v 
\end{verbatim}

\begin{flushright}
The {\bf *} symbol is used as shorthand for {\bf sets} rather \\
than the more obvious {\bf =} since a resource usage statement \\
containing it will already include a {\bf =} symbol.
\end{flushright}

\index{\M{resource\_unit}}
\index{\M{resource\_unit\_name}}
\index{\M{resource\_unit\_synonym}}
\index{\M{resource\_scope\_spec}}
\index{\M{resource\_usage\_keyword}}
\index{{\bf overall}}
\index{{\bf unlimited}}
\index{{\bf resource\_usage\_node\_end}}
\index{{\bf sets}}
\index{{\bf allocates}}
\index{{\bf deallocates}}
\index{{\bf produces}}
\index{{\bf consumes}}

The keyword {\bf overall} when stated as a \M{resource\_scope\_spec} allows
{\em resource specification} for the schema.  This sets a bound on the
resource allowed to be used in any expansion of the schema as given in {\em
resource utilisation} statements which always have an {\bf at}
\M{node\_end}.  The single character \M{resource\_usage\_keyword}s given
above are synonyms for the longer forms shown on each line.  These short forms
normally are used in printouts of resource usage statements in O-Plan.

\begin{verbatim}
   consumes {resource money} = 0..1000 dollars overall
\end{verbatim}

This sets a (min, max) pair on the whole action, i.e.  it sets the limits
within which resources used in schema and any expansion of it will be
confined.  In this case it would limit the amount of money spent to 1000
dollars.  The {\bf overall} default limits are (0, infinity).

There are limitations on the \M{resource\_usage\_keywords} that may be
given in a \M{resource\_usage\_spec} for a given \M{resource\_name}
depending on the \M{resource\_class} it is declared to belong to.  These
are shown in the table below.
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\M{resource\_class}           & initial\_resources & usage in a schema \\
\hline
consumable\_strictly            & sets/produces & consumes \\
consumable\_producible\_by\_agent & sets/produces & consumes/produces\dag \\
consumable\_producible\_outwith\_agent & sets/produces
                                       & consumes/produces\dag \\
consumable\_producible\_by\_and\_outwith\_agent & sets/produces
                                       & consumes/produces \\
\hline
reusable\_non\_sharable         & sets/produces & allocates/deallocates \\
                                &              & (paired) \\
reusable\_sharable\_independently & sets/produces & ditto \\
reusable\_sharable\_synchronously & sets/produces & ditto \\
\hline
\end{tabular}
\end{center}

\dag {\tt produces} only allowed in a process schema (not a normal
schema describing an agent's deliberate actions) for
consumable\_producible\_outwith\_agent and only allowed in a normal schema
(not a process schema describing activities outside of the agent's direct
control) for consumable\_producible\_by\_agent.

\subsection{Authority Statements}
\index{authority statements}

Authority to plan to a given level or to execute a plan is provided via the
Task Assignment agent in O-Plan.  {\sc tf} provides support to ensure that
relevant information can be communicated to the planner.

\begin{verbatim}
   <authority_statement> ::=  <provides_or_requires> <individual_authority>

   <provides_or_requires> ::= provides | requires

   <individual_authority> ::= {authority plan <phase_number>} = <level_number>
                            | {authority execute <phase_number>} = <yes_or_no>

   <phase_number> := <node_number> | all
\end{verbatim}

\M{node\_number} will refer to a node within the nodes component of a task.
Note that this is only suitable for one task.

\begin{verbatim}
   <level_number> ::= 0 | 1 | ... | inf | infinity
\end{verbatim}

A \M{level\_number} can range up the maximum number of plan levels
(and the special ``level'' {\bf inf} or {\bf infinity}).

\begin{verbatim}
   <yes_or_no> := yes | no
\end{verbatim}
\index{\M{authority\_statement}}
\index{\M{individual\_authority}}
\index{\M{provides\_or\_requires}}
\index{\M{phase\_number}}
\index{\M{level\_number}}
\index{\M{yes\_or\_no}}

\opsection{TF Forms}
\index{TF forms}

Domain information is provided to the O-Plan Planner via a {\sc tf} input file
which is translated by the {\sc tf} Compiler.  A {\sc tf} file is
made up of {\sc tf} forms.  The {\sc tf} Compiler operates in a single pass
over the input file.  The Task Formalism language syntax is designed to
allow this.

\begin{verbatim}
   <tf_file> ::= [ <tf_form> ]
                 ...
\end{verbatim}
\index{\M{tf\_file}}

There are a limited number of {\sc tf} forms.  They can be given in any order,
and more than one particular form can appear in any separate {\tt
\M{tf\_file}}.  Later forms add to the information extracted from earlier
forms.  The only requirement on the order in which forms are given is that
information used in later forms be available before use.

\begin{verbatim}
   <tf_form_keyword> ::= defaults | include | plan_viewer | world_viewer |
                       resource_units | resource_types | default_resources |
                       domain_rules | compute_condition | always | types |
                       initially | initial_resources | initial_authority |
                       initial_time

   <tf_form_major_keyword> ::= tf_info | plan_levels |
                               preferences | language |
                               [meta_][process_]schema | task
\end{verbatim}
\index{\M{tf\_form\_keyword}}
\index{\M{tf\_form\_major\_keyword}}
\index{{\bf end\_\M{keyword}}}

{\sc tf} forms have a regular structure.  Each is introduced by a
keyword and ends with a semi-colon.  Internal terms are separated by
``,''.  Where there is a compound {\sc tf} form which has several
internal keyword forms (e.g. for a schema definition), then the outer
level form is introduced by a keyword and ended by {\bf
end\_\M{keyword}}.  Thus the general structure of {\sc tf} is:

\begin{verbatim}
   <tf_form> ::=   <tf_form_keyword> <component> ,
                                     ...

                 | <tf_form_major_keyword> <component> ,
                                           ... ;
                       <minor_keyword> <component> ,
                                       ... ;
                       ...
                   end_<tf_form_major_keyword>

   <minor_keyword> ::= see specific <tf_form> definition

   <component> ::= see specific <tf_form> definition
\end{verbatim}
\index{\M{tf\_form}}
\index{\M{minor\_keyword}}
\index{\M{component}}

\subsection{Documentary Information}
\index{documentary information}
\begin{verbatim}
   tf_info <info_word> <text_string> ;
           ...
   end_tf_info;

   <info_word> ::= <name>
\end{verbatim}
\index{{\bf tf\_info}}
\index{\M{info\_word}}

For example the \M{info\_word} could be title, author, date, history or
description, etc.

\subsection{TF Compiler Defaults}
\index{TF, compiler defaults}

The {\sc tf} Compiler provides defaults for a number of components of
{\sc tf} forms if they are not given.  For example, for \M{pattern}
[ = \M{value} ], the \M{value} is optional.  If not provided, the
default (normally {\bf true}) is used instead.  The {\sc tf} {\bf
defaults} statement allows certain defaults to be altered.  The {\sc tf}
complier will use the relevant defaults for all {\sc tf} forms entered
after the end of the {\bf defaults} statement and will use these
defaults until a new domain is specified to O-Plan. 
\index{{\bf new\_domain}}

\begin{verbatim}
   defaults <default_assignment> ,
            ... ;

   <default_assignment> ::= value = <value>
                         | variable_restriction = <variable_restriction>
                         | condition_at_node_end = <end>
                         | condition_contributor_node_end = <end>
                         | achieve_after_point = <default_achieve_after_point>
                         | effect_at_node_end = <end>
                         | resource_usage_node_end = <end>
                         | time_window_node_end = <end>
                         | link_from_node_end = <end>
                         | link_to_node_end = <end>
                         | resource_overall = <min_max_spec>
                         | resource_at_node_end = <min_max_spec>

   <default_achieve_after_point> ::= [begin_of] self | [end_of] start
\end{verbatim}
\index{{\bf defaults}}
\index{{\bf value}}
\index{{\bf variable\_restriction}}
\index{{\bf condition\_at\_node\_end}}
\index{{\bf condition\_\_contributor\_node\_end}}
\index{{\bf achieve\_after\_point}}
\index{{\bf effect\_at\_node\_end}}
\index{{\bf resource\_usage\_\_node\_end}}
\index{{\bf time\_window\_node\_end}}
\index{{\bf link\_from\_node\_end}}
\index{{\bf link\_to\_node\_end}}
\index{{\bf resource\_overall}}
\index{{\bf resource\_at\_node\_end}}
\index{\M{default\_assignment}}
\index{\M{default\_achieve\_after\_point}}

The following default are used by the {\sc tf} Compiler if a defaults
statement has not been given for any defaulted component.

\begin{verbatim}
   defaults value = true,
            variable_restriction = undef,
            condition_at_node_end = begin_of,
            condition_contributor_node_end = end_of,
            achieve_after_point = begin_of self,
            effect_at_node_end = end_of,
            resource_usage_node_end = begin_of,
            time_window_node_end = begin_of,
            link_from_node_end = end_of,
            link_to_node_end = begin_of,
            resource_overall = (0..infinity),      i.e. some
            resource_at_node_end = (0..0);         i.e. none
\end{verbatim}


\subsection{Including files}

\begin{verbatim}
   include <file_name>;

   <file_name> ::= <text_string>
\end{verbatim}
\index{{\bf include}}

The {\bf include} statement causes the contents of the indicated file
to be processed by the TF compiler.  It can be used, for instance, when
it is convenient to break up a large file into sections, or when some
TF definitions should be part of several several different domain
descriptions.


\subsection{User Interface Specification}
\index{user interface specification}

The user interface for O-Plan is supported through two {\em viewers} --
a {\em Plan View} and a {\em World View} of the plan.  O-Plan provides
default viewers for each of these in a domain independent way.  However,
it is anticipated that replacement or domain specific viewers will be provided
for realistic applications.  This can be done with the {\bf plan\_viewer} and
{\bf world\_viewer} {\sc tf} forms.

\subsubsection{Plan View}
\index{plan view}

\begin{verbatim}
   plan_viewer program = <plan_viewer_program_name>
               [ , information = <plan_viewer_parameter_string> ]
               [ , <plan_viewer_feature> = <availability> ]
               ... ;

   <plan_viewer_program_name> ::= <text_string>

   <plan_viewer_feature> ::= plan_output | levels_output | resource_output |
                             node_selection | link_selection | entity_detail |
                             tf_input

   <availability> ::= yes | no
\end{verbatim}

The default is {\bf yes} for plan viewer features
listed in the {\sc tf} form, otherwise {\bf no}.

\begin{verbatim}
   <plan_viewer_parameter_string> ::= <text_string>
\end{verbatim}
\index{{\bf plan\_viewer}}
\index{{\bf program}}
\index{{\bf information}}
\index{\M{plan\_viewer\_feature}}
\index{\M{availability}}
\index{\M{plan\_viewer\_parameter\_string}}

The plan viewer is initiated as a separate shell process and is called
with the command {\tt \M{plan\_viewer\_program\_name}
\M{plan\_viewer\_parameter\_string} \& }.  The process is connected
via a two way communications channel (on {\sc unix} a {\em pipe}) to and
from an O-Plan process.  The \M{plan\_viewer\_parameter\_string} may
hold the detail of a domain specific or plan viewer specific file of
information to be used in the plan viewer (such as icons for nodes in
the plan, etc) as well as giving any necessary shell command modes and
flags.  A recommended format for a file holding details for a
plan viewer program is provided, but variations for specific plan viewers
are possible. 

The features of a plan viewer are as follows:

\begin{description}

\item[{\bf plan\_output}] indicates that the plan viewer can accept
output from the planner in the {\em O-Plan plan output format}.  A
simple textual presentation of this information is possible.  Note that
it is assumed that all plan viewers should have the {\bf plan\_output}
feature available -- it would be unhelpful of a plan viewer not to
provide this feature at least in a simple form!
\index{{\bf plan\_output}}


\item [{\bf levels\_output}]
\index{{\bf levels\_output}}
indicates that the plan viewer can show information about levels of a plan in
a useful form.

\item[{\bf resource\_output}]
\index{{\bf resource\_output}}
indicates that the plan viewer can show information about resource usage
perhaps in the form of gantt charts, capacity profiles, etc.

\item[{\bf node\_selection}]
\index{{\bf node\_selection}}
indicates that the plan viewer is able to give input to O-Plan showing nodes
being pointed at in the last plan which was output.  The node numbers given in
that output will be passed for any node selected in the plan viewer by the
user.

\item[{\bf link\_selection}]
\index{{\bf link\_selection}}
indicates that the plan viewer is able to give input to O-Plan showing
links being pointed at in the last plan which was output.  A pair of
node numbers is produced by the plan viewer (relative to node numbers
given in the last plan output) representing the end nodes of any link
selected in the plan viewer by the user. 

\item[{\bf entity\_detail}]
\index{{\bf entity\_detail}}
indicates that the plan viewer can display detail of nominated entities.

\item[{\bf tf\_input}]
\index{{\bf tf\_input}}
indicates that the plan viewer can produce {\sc tf} input in a legitimate
format (for example, if tasks can be specified in the plan viewer by some
means, or if actions, resource profiles, etc can be ``drawn'' and converted to
legitimate {\sc tf}).  One way in which this can be done is by the provision of
drawing aids for actions, links, conditions, effects, etc.

\end{description}

% /\/: Durations are not really available.

The {\em O-Plan plan output format} is introduced by the single word {\bf
plan} on one line followed by statements describing nodes.  Nodes are
introduced with the single word {\bf node} on one line followed by a fixed
number of lines as described below.  A node statement is terminated with the
single word {\bf end\_node} on a separate line.  The plan output format is
terminated by the single word {\bf end\_plan} on a separate line.  Leading
spaces and tab characters on any line may be ignored.  Blank lines in the
output may be ignored.

\begin{verbatim}
   plan
      node
         <node_reference>
         ( [ <predecessor of begin_end> ... ] )
         ( [ <successor of begin_end> ... ] )
         ( [ <predecessor of end_end> ... ] )
         ( [ <successor of end_end> ... ] )
         <node_time_information>
         <node_type>
         <node_label>
      end_node
      ...
   end_plan

  <predecessor of begin_end> | <successor of begin_end> |
    <predecessor of end_end> | <successor of end_end>
       ::= <end> <node_reference>

  <node_reference> ::= node-<integer>[-<integer> ...]

  <node_label> ::= " [ <character> ... ] "

  <node_time_information> ::= ( <earliest_begin_time>
                                <latest begin_time>
                                <earliest_end_time>
                                <latest_end_time>
                                <minimum_duration>
                                <maximum_duration> )

  <earliest_begin_time> | <latest begin_time> | 
    <earliest_end_time> | <latest_end_time>   |
    <minimum_duration>  | <maximum_duration>  ::= <integer>
\end{verbatim}
\index{{\bf plan}}
\index{{\bf end\_plan}}
\index{{\bf node}}
\index{{\bf end\_node}}
\index{plan output format}
\index{O-Plan plan output format}
\index{\M{node\_reference}}
\index{\M{node\_label}}
\index{\M{node\_time\_information}}
\index{\M{earliest\_begin\_time}}
\index{\M{latest\_begin\_time}}
\index{\M{earliest\_end\_time}}
\index{\M{minimum\_duration}}
\index{\M{maximum\_duration}}

It is useful to know that \M{node\_reference}s easily show the expansion
level at which a node was introduced into a plan.  An example node number for
a top level node such as the {\bf finish} node of a plan is ``node-2''.  A
node which is at the third level might have a \M{node\_reference} of
``node-15-2-4''.

If the plan viewer can call on a file of information to tailor
its output, it is recommended that it contain entries in the following format
(where this is possible).

\begin{verbatim}
   <drawing_object_name> -> <associated_instructions_or_data>

   <drawing_object_name> ::=   <action_or_event> <drawing pattern>
                             | <dummy_node_type>

   <drawing_pattern> ::= <fully_instantiated_pattern> | <pattern_with_??>

\end{verbatim}
\index{\M{drawing\_object\_name}}
\index{\M{drawing\_pattern}}
\index{\M{associated\_instructions\_or\_data}}
\index{\M{fully\_instantiated\_pattern}}
\index{\M{pattern\_with\_??}}

\M{fully\_instantiated\_pattern} and \M{pattern\_with\_??}
are patterns not containing match restrictions or variables.

The \M{associated\_instructions\_or\_data} could hold icon filenames or
drawing instructions, etc.

\subsubsection{World View}
\index{world view}

\begin{verbatim}
   world_viewer program = <world_viewer_program_name>
               [ , information = <world_viewer_parameter_string> ]
               [ , <world_viewer_feature> = <availability> ]
               ... ;

   <world_viewer_program_name> ::= <text_string>

   <world_viewer_feature> ::= snapshot | incremental | tf_input

   <availability> ::= yes | no
\end{verbatim}

The default is {\bf yes} for world viewer features
listed in the {\sc tf} form, otherwise {\bf no}.

\begin{verbatim}
   <world_viewer_parameter_string> ::= <text_string>
\end{verbatim}
\index{{\bf world\_viewer}}
\index{{\bf program}}
\index{{\bf information}}
\index{\M{world\_viewer\_feature}}
\index{\M{availability}}
\index{\M{world\_viewer\_parameter\_string}}

The world viewer is initiated as a separate shell process and is called with
the command {\tt \M{world\_viewer\_program\_name}
\M{world\_viewer\_parameter\_string} \& }.  The process is connected via a
two way communications channel (on {\sc unix} a {\em Pipe}) to and from an
O-Plan process.  The \M{world\_viewer\_parameter\_string} may hold the
detail of any domain specific drawing and presentation information necessary
to specialise the world viewer program as well as giving any necessary shell
command modes and flags.  A recommended format for a file holding details for
a world viewer program is made, but variations for specific world viewer
programs is possible.

The features of the world viewer program are as follows.

\begin{description}

\item[{\bf snapshot}]
\index{{\bf snapshot}}
indicates that the world viewer program can accept a sets of facts and
statements about the world state in the form of the {\em O-Plan world
output format} and can present this to the user.  A simple textual
presentation of this information is possible. 

\item[{\bf incremental}]
\index{{\bf incremental}}
indicates that it is possible to follow the initial startup of the program or
any snapshot output (if that feature is available) with {\em changes} in the
world state which the planner wishes to display.  These are in the same format
as the full snapshot {\em O-Plan world output format} but present only a
partial description of a context in the plan.

\item[{\bf tf\_input}]
\index{{\bf tf\_input}}
indicates that the world viewer program can produce {\sc tf} input in a
legitimate format (for example, if tasks can be specified in the
world viewer program by some means, or if initial information can be
provided (e.g.  an initial world state) and these can be converted to
legitimate {\sc tf}).  One mechanism is to allow the drawing of objects
directly in the domain (such as the features of a building or structure,
or the placing of objects on a map) and to convert these to {\bf
initially} or {\bf always} {\sc tf} statements. 
\index{{\bf initially}} 
\index{{\bf always}}

\end{description}

The proposed user interface for O-Plan allows for facilities for
context snapshot image saving (in a {\em pic}) and recording and playback
of a series of such images (in {\em flicks}) to be provided.  However, these
will be provided and managed by the world viewer program and are thus not part
of the definition of the world viewer system in TF.

The {\em O-Plan world output format} is introduced by the word {\bf world}
followed by a keyword {\bf snapshot} or {\bf increment} on one line
followed by statements of the form shown on a single line with a line {\bf
end\_world} being used to terminate the output.

\begin{verbatim}
   world <world_view_type>
      <pattern> = <value>
      ...
   end_world

   <world_view_type> ::= snapshot | increment
\end{verbatim}
\index{{\bf world}}
\index{{\bf end\_world}}
\index{{\bf increment}}
\index{\M{world\_view\_type}}
\index{world output format}
\index{O-Plan world output format}

If the world viewer program can call on a file of information to tailor
its output, it is recommended that it contains entries in the following format
(where this is possible).

\begin{verbatim}
   <domain_statement> = <domain_value> -> <associated_instructions_or_data>

   <domain_statement> | <domain_value> ::=  <fully_instantiated_pattern>
                                          | <pattern_with_?? >
\end{verbatim}
\index{\M{domain\_statement}}
\index{\M{domain\_value}}
\index{\M{associated\_instructions\_or\_data}}

The \M{associated\_instructions\_or\_data} could hold drawing instructions,
etc.

\subsection{Plan Levels}
\index{plan levels}

The {\bf plan\_levels} {\sc tf} form allows a description of the names of
actions, events, effects and resources introduced at each distinct level.

\begin{verbatim}
  plan_levels <number> [ actions = ( <pattern> ... ), ]
                       [ events = ( <pattern> ... ), ]
                       [ effects = ( <pattern> ... ), ]
                       [ resources = ( <pattern> ... ) ] ;
              ...
  end_plan_levels;
\end{verbatim}

\subsection{Preferences and Heuristic Information}
\index{preferences}
\index{heuristic information}

Preferences can be stated to help the planner choose between valid
options it encounters.

\begin{verbatim}
   preferences <preference_statement> ;
               ...
   end_preferences;

   <preference_statement> :=  prefer_plans_with <number> <preference_word> ,
                                                ... ;
                            | prefer_schemas <pattern> [ = <value> ]
                                                   use (<schema_name> ... ) ,
                                             ... ;

   <preference_word> ::= { resource <resource_name>
                                   [ <resource_qualifier> ... ] }
                         | <plan_feature>

   <plan_feature> ::= earliest_finish_of_plan |
                      latest_finish_of_plan | 
                      number_of_nodes
\end{verbatim}
\index{{\bf preferences}}
\index{{\bf prefer\_plans\_with}}
\index{\M{preference\_word}}
\index{\M{plan\_feature}}
\index{{\bf prefer\_schemas}}
\index{{\bf earliest\_finish\_of\_plan}}
\index{{\bf latest\_finish\_of\_plan}}
\index{{\bf number\_of\_nodes}}

The preference information in {\bf prefer\_plans\_with} is used to construct
the heuristic evaluator to be used by the planner to compare different plans
for continued development.  Including a resource statement in the preference
description means that lower utilisation of the resource indicated is
treated as preferential to higher resource utilisation levels.

The preference \M{number} should be 1 for those resources or plan features
which are most important in a plan.  Progressively higher numbers may be used
to indicate other resources or plan features which affect the value of a plan
in a progressively less important way.  It is possible to give the same number
two or more times to indicate that two resources or plan features are of equal
importance in rating alternative plans.  For example:

\begin{verbatim}
   preferences
      prefer_plans_with 1 latest_finish_of_plan,
                        2 {resource fuel Port_1},
                        2 {resource fuel Port_2},
                        3 {resource money};
   end_preferences;
\end{verbatim}

{\bf earliest\_finish\_of\_plan} is a measure of the earliest time at which
the plan may finish.  {\bf latest\_finish\_of\_plan} is a measure of the
latest time at which the plan may finish.  {\bf number\_of\_nodes} counts the
``complexity'' of the plan.

The {\bf prefer\_schemas} statement gives the order in which the various
schemas that can be used to expand an action pattern or used to achieve
an {\bf achieve} condition should be tried after ruling out any
non-applicable schemas with the filter information provided.  Any
schemas not mentioned in a {\bf prefer\_schemas} statement but which can
be used to expand an action pattern or to achieve a condition are used
in the order they are presented to the planner, but after the ones
declared as preferred. 

\subsection{Resource Information}
\index{resource information}

Resources statements are of the form:

\begin{tabbing}
   {\tt {resource \var{name} \var{qualifier} ... }
       = \var{number} [\var{units}]}
\end{tabbing}

Examples are:
\begin{verbatim}
    {resource money} = 145 dollars
    {resource fuel port_A tank_C} = 15000 gallons
    {resource bricks site_567} = 10000
\end{verbatim}

That no units are specified means that individual brick units are used.

The following unit and resource type declaration statements give the
information which will allow the O-Plan {\sc tf} Compiler and planner to
correctly handle resource declarations in later {\sc tf}.

\begin{verbatim}
  resource_units <resource_unit_name> [ / <resource_unit_synonym> ]
                                        ...
                        [ = <resource_unit_class> ] ,
                 ... ;

  resource_types <resource_class>
                       { resource <resource_name>
                                 [ <resource_qualifier_spec> ] ... }
                       [ = <resource_unit> ] ,
                 ... ;

  resource_conversions <to be defined> ;
\end{verbatim}
\index{{\bf resource\_units}}
\index{{\bf resource\_types}}
\index{{\bf resource\_conversions}}

{\bf resource\_conversions} allows resource unit or resource type conversions
in one or two directions.  Schemas can be used to define the production of one
resource from another.  However, the {\bf resource\_conversion} statement may
provide a convenient shorthand for some conversions.

\begin{verbatim}
  <resource_unit_class> ::= count | size | weight |
                            set ( <name> , ...)             default is count

  <resource_class> ::= consumable_strictly |
                       consumable_producible_by_agent |
                       consumable_producible_outwith_agent |
                       consumable_producible_by_and_outwith_agent |
                       reusable_non_sharable |
                       reusable_sharable_independently |
                       reusable_sharable_synchronously

  <resource_qualifier_spec> ::= <pattern_component>
\end{verbatim}
\index{\M{resource\_unit\_class}}
\index{\M{resource\_class}}
\index{\M{resource\_qualifier\_spec}}

Examples are:

\begin{verbatim}
   resource_units  person/people = count,
                   gallons = count;

   resource_types consumable_strictly {resource money} = dollars,
                  consumable_producible_by_agent
                      {resource fuel ?{type port} ?{type tank} } = gallons;
\end{verbatim}

The following notes apply to resource definitions:

\begin{itemize}

\item 
Names specified in the {\bf resource\_units}
statement are used to define unit types such as person/people, gallons,
kilograms, etc.  These are later used in {\bf resource\_types}
declarations. 

\item 

The unit type needs to be one of the following {\bf count}
{\bf size}, {\bf weight} or {\bf set}.  If a set is specified then the full
enumeration of the set should be defined.  If not specified the unit type is
assumed to be {\bf count}.  Only the {\bf count} resource unit class is
supported by O-Plan at present.
\index{{\bf count}}
\index{{\bf size}}
\index{{\bf weight}}
\index{{\bf set}}

\end{itemize}

Not all of the \M{resource\_class}es are provided at present, and a more
thorough consideration of their individual utility and necessity is still to
be conducted.

As described earlier, the class of a resource will limit the types of
resource usage statement that can be provided in an {\bf
initial\_resources} statement or in a {\bf only\_use\_for\_resources} or
{\bf resources} clause of a schema.  For example, a {\bf
consumable\_strictly} resource cannot be {\bf produced} in a schema. 
\index{{\bf initial\_resources}}
\index{{\bf only\_use\_for\_resources}}
\index{{\bf resources}}

\subsection{Default Resource Information}
\index{default resource information} \index{resources, defaults}

This statement can be used to indicate default resource information
about certain actions.  Via this statement it is possible to
give bounds on resource usage for higher level actions, prior to specific
resource usage statements at the lower levels of detail.  This can be helpful
in avoiding wasted search.  The default information
is overridden by any specific statement
about a specific resource for the same end of any action.  It is
used at compile time by the {\sc tf} Compiler.

\begin{verbatim}
   default_resources <pattern>
                          { resource <resource_name>
                                    [ <resource_qualifier> ... ] } =
                                 [ <resource_usage_keyword> ]
                                 <resource_range>
                                 [ <resource_unit> ]
                                 [ overall | at begin_of | at end_of ] ,
                          ... ;
                     ...  ;
\end{verbatim}
\index{{\bf default\_resources}}
\index{{\bf overall}}
\index{{\bf at begin\_of}}
\index{{\bf at end\_of}}

The {\bf overall}, {\bf at begin\_of} or {\bf at end\_of} term is given
after the resource usage declaration in a position compatible with
resource usage specifications given in schemas.  The default if this is
not specified is {\bf overall}. 

The indicated number of units of the given resource will be assumed to
be {\em set, allocated, deallocated, produced} or {\em consumed} whenever the
\M{pattern} appears as an action in the plan. However this
is only the default situation as this can be locally overridden for
any specific resource used by the action with name
\M{pattern} used in a particular schema expansion by
explicitly declaring a resources clause for the node which specified that 
action.

\subsection{Calendar and Time Information}
\index{calendar}
\index{time information}
\index{time units}

All time specifications map to a number of {\em time units} kept
as integers in O-Plan.  By default these time units are assumed to refer to
seconds.  It is intended that calendar information and more flexible
references to time points will be possible in future releases.
 
\subsection{Domain Constraints}
\index{domain constraints}

\begin{verbatim}
   domain_rules [ forall <variable_name> [ = <variable_restriction> ] ,
                         ... ]
                    <pattern> [ = <value> ] [ & [ <pattern> [ = <value> ] ]
                                            ...
                                       => <pattern> [=<value>] ,
                ... ;
\end{verbatim}

For example:
\begin{verbatim}
  domain_rules forall ?a=?{type block}, ?b=?{type block},
                            {on ?a ?b}=true => {cleartop ?b}=false;
\end{verbatim}
\index{{\bf domain\_rules}}
\index{{\bf forall}}
\index{{\bf $\Rightarrow$}}

The {\bf domain\_rules} {\sc tf} form is used to state implied
relationships between statements about the domain. 
\index{{\bf domain\_rules}}
\index{temporal coherence}
O-Plan1 was able to use information about sets of inconsistent conditions to
guide preferences about ordering of choices using a heuristic called {\em
Temporal Coherence}.  Domain rules can also provide input to this heuristic
since if {\bf A=v1 \& B=v2 $\Rightarrow$ C=v3} then a requirement for the set
of conditions {\bf (A=v1, B=v2, C=not(v3))} is obviously inconsistent.  Such
an inconsistency can sometimes be avoided by temporal displacement of the
establishment of one or more members of the set, but this will usually require
more work than attempting other search paths.  Although the use of Temporal
Coherence to exploit this heuristic was used within O-Plan1, it is not
currently used in O-Plan.

\subsection{Compute Conditions}
\index{compute condition}

Domain specific compute functions which may be used in the {\bf compute}
condition clause within a schema must be declared to the planner via the {\bf
compute\_condition} statement.
\index{{\bf compute}}

% /\/: Why is it compute_condition (singular) when types, etc are plural?

\begin{verbatim}
   compute_condition
      [multiple_answer] { <compute_function_name> [ <pattern_component> ... ]}
                                          = <value>
                        [ depends_on <compute_dependency>
                                     ...  ] ,
      ... ;

   <compute_function_name> ::= <name>
\end{verbatim}
\index{{\bf depends\_on}}
\index{{\bf compute\_condition}}
\index{{\bf multiple\_answer}}
\index{{\bf depends\_on}}
\index{\M{compute\_function\_name}}
\index{\M{compute\_dependency}}

The keyword {\bf multiple\_answer} is stated if
the compute condition can give alternative answers.  Otherwise a single
answer is assumed.  The optional {\bf depends\_on}
clause must be given if the compute condition requires specific
conditions to be maintained by the planner for the answers to be valid. 
The \M{pattern}s in the declaration give restrictions on bindings for
the various parameters and the answer pattern format. 

\index{conditions, compute dependency statement}
A {\bf compute} condition may have a {\bf depends\_on} phrase.  The
format is as follows:

\begin{verbatim}
   <compute_dependency> ::= <pattern> [ = <value> ] [ from <variable_name> ]
\end{verbatim}
\index{\M{compute\_dependency}}

A set of pre-defined compute conditions with names starting with {\bf
fn\_} are provided in the O-Plan system.  See the relevant
section of this manual for those currently available. 
\index{{\bf fn\_}} 

\subsection{Language Specific Code}
\index{language specific code}

It is possible to refer to specific language code relating to a domain
description by using the {\bf language} statement.  This can be useful to
define \M{compute\_function\_name} routines in particular.

\begin{verbatim}
   language <language_name>;
      <language_statement>
      ...
   end_language ;

   <language_name> ::= lisp
\end{verbatim}
\index{{\bf language}}
\index{{\bf lisp}}
\index{\M{language\_name}}

Only Lisp is supported at present

An example is:
\begin{verbatim}
   language lisp;
     (set-paramater :psgraph-all-nodes t)
     (load "some-compute-functions")
   end_language;
\end{verbatim}

\subsection{Object Types} \index{object types}

\begin{verbatim}
   types <type_name> = <name_set> | <integer_range> ,
         ... ;

   <type_name> ::= <name>

   <integer_range> ::= ( <integer> .. <integer> )
\end{verbatim}
\index{{\bf types}}
\index{\M{type\_name}}
\index{\M{integer\_range}}
\index{type, integer range}

The {\bf types} statement specifies and names a class of
objects within the domain.  One or more of these types can then be
specified within a variable declaration to describe the possible set of
bindings for the variable.  For example:

\begin{verbatim} 
    types objects = (a b c d table),
          movable-objects = (a b c d),
          count = (1 .. 10);
\end{verbatim}

It is then possible to give a variable restriction such as ?\{type
movable-objects\}.

\subsection{Global Data} \index{global data}

Statements which always hold in the domain may be given
with the {\bf always} {\sc tf} form.

\begin{verbatim}
   always  <pattern> [ = <value> ] ,
           ...  ;
\end{verbatim}
\index{{\bf always}}

Any {\bf always} entry overrides any schema effect (for example, this may
occur if a schema has asserted the effect {\tt \{clear ?x\} = false} where ?x
has been bound to the ``table'', but the ``table'' has been declared {\bf
always} {\tt \{clear table\} = true}).

No match restrictions (e.g. {\tt ??} or {\tt ?\{not table\}}) are allowed in
a \M{pattern} = \M{value} of an {\bf always} statement.

It is anticipated that facilities will be added to the {\bf always}
statement to set up a class/sub-class instance hierarchy of objects with
attributes which have single values inherited from their
super-class(es).  Patterns of form {\tt \{\M{attribute} \M{object}\} =
\M{value}} will be able to match against {\bf always}
object/attribute/value definitions given in the anticipated form.
Hence, for the moment, it is suggested that global data that could be
more clearly written in a class/sub-class/instance format be represented
in a number of statements of form {\tt \{\M{attribute} \M{object}\} =
\M{value}}. 

\subsection{Actions and Schemas}
\index{actions}
\index{schemas}

The schema is the main form in Task Formalism.

Except for the keywords {\bf schema} and {\bf end\_schema} and the
\M{schema\_name} and subject to the restriction that a usable schema will
have at least one of the {\bf expands}, {\bf only\_use\_for\_effects}, {\bf
only\_use\_for\_resources} or {\bf only\_use\_for\_authority} statements, all
other sub-clauses of a schema are optional and their ordering can be quite
flexible (in general introduce types, variables or node numbers before use
elsewhere).

To improve readability in the description below the [ ] brackets which should
indicate that each sub-clause is optional at the top level of a schema are
omitted.

\begin{verbatim}
   [meta_][process_]schema <schema_name>;

   instance_of <meta_schema_name> ;

   ;;; public information

   info <info_word> <text_string> ,
        ... ;

   vars    <variable_name>  [ =  <variable_restriction> ] ,
           ... ;

   expands <pattern> ;

   only_use_for_effects    <pattern>  [ = <value> ]  [ at <effect_point> ] ,
                           ... ;

   only_use_for_resources  <resource_usage_spec> ,
                           ... ;

   only_use_for_authority  <authority_statement> ,
                           ... ;

   ;;; private information

   local_vars   <variable_name>  [ = <variable_restriction> ] ,
                ... ;

   vars_relations <variable_name> <relationship> <variable_name> ,
                  ... ;

   nodes   <node_spec> ,
           ... ;

   orderings    <node_end>  [ --- <delay_spec> ]  ---> <node_end> ,
                ... ;

   conditions   <condition_statement> ,
                ... ;

   effects         <pattern>  [ = <value> ]  [ at <effect_point> ] ,
                   ... ;

   resources       <resource_usage_spec> ,
                   ... ;

   authority       <authority_statement> ,
                   ... ;

   time_windows    <time_window_spec> ,
                   ...  ;

   <other_constraint_clause> ;
   ...

   end_schema ;
\end{verbatim}
\index{{\bf --$ $}}
\index{{\bf ---$>$}}
\index{{\bf schema}}
\index{{\bf meta\_schema}}
\index{{\bf process\_schema}}
\index{{\bf meta\_process\_schema}}
\index{schemas, public information}
\index{{\bf info}}
\index{{\bf instance\_of}}
\index{{\bf expands}}
\index{{\bf only\_use\_for\_effects}}
\index{{\bf only\_use\_for\_resources}}
\index{{\bf only\_use\_for\_authority}}
\index{{\bf vars}}
\index{{\bf vars\_relationships}}
\index{schemas, private information}
\index{{\bf local\_vars}}
\index{{\bf nodes}}
\index{{\bf orderings}}
\index{{\bf conditions}}
\index{{\bf effects}}
\index{{\bf resources}}
\index{{\bf authority}}
\index{{\bf time\_windows}}
\index{\M{other\_constraint\_clause}}

The sub-clauses in the various forms of {\bf schema} contain
the following components.

\begin{verbatim}
   <node_spec> ::= <node_number> <node_form>
                |  <ordering_block>

   <node_form> ::= dummy | start | finish
                |  action <pattern>
                |  event <pattern>
                |  iterate <iterated_node_form>
                |  foreach <iterated_node_form>

   <iterated_node_form> ::= <iterated_node_type> <pattern> for <iterators>

   <iterated_node_type> ::= action | event

   <iterators> ::= <variable_name> over <iteration_set>
                   [and <iterators>]

   <iteration_set> ::= <pattern_component>

   <ordering_block> ::= sequential <node_spec> ... end_sequential
                     |  parallel <node_spec> ... end_parallel

   <effect_point> | <condition_point> ::= <node_end> | notepad

   <delay_spec> ::= <time_bounds_spec>

   <time_window_spec> ::= <time_bounds_spec>  [ <at_spec> ] |
                          duration <node_number> = <time_bounds_spec> |
                          duration self = <time_bounds_spec> |
                          delay_between <node_end> [ and | : ] <node_end>
                                                 = <delay_spec>
\end{verbatim}
\index{{\bf iterate}}
\index{{\bf foreach}}
\index{{\bf sequential}}
\index{{\bf parallel}}
\index{{\bf duration}}
\index{{\bf delay\_between}}
\index{\M{node\_spec}}
\index{\M{node\_form}}
\index{\M{iterated\_node\_form}}
\index{\M{iterated\_node\_type}}
\index{\M{iterators}}
\index{\M{iteration\_set}}
\index{\M{ordering\_block}}
\index{\M{effect\_point}}
\index{\M{condition\_point}}
\index{\M{delay\_spec}}
\index{\M{time\_window\_spec}}

Initially, only a framework for other constraints is provided to allow
for experimentation.  One possible experiment might be the inclusion
of a {\em spatial} constraint manager.
\index{spatial constraints}
\index{constraints, spatial}

The {\bf conditions} sub-form is one of the most complex
statement in {\sc tf} and has a number of options.

\begin{verbatim}
   <condition_statement> ::=
               supervised <pattern> [ = <value> ]
                             at <condition_point> from <contributor_entry> |

               achieve <pattern> [ = <value> ]
                             [ at <condition_point> ]
                             [ after <achieve_after_point> ] |

               <limited_condition_type> <pattern> [ = <value> ]
                             [ at <condition_point> ] |

               compute { <compute_function_name> [ <pattern>
                                                   ... ] } = <general_pattern>
                                           [ at <condition_point> ]
                                           [ depends_on <compute_dependency>
                                                        ...  ]

   <limited_condition_type> ::= unsupervised | 
                                only_use_if | only_use_for_query

   <contributor_entry> ::= <node_end> | ( <node_end> ... ) 
                         | [ <node_end> ... ]
\end{verbatim}

\begin{flushright}
The [ \M{node\_end} ... ] square bracketed alternative \\
syntax above is a valid option. The [ ] brackets here do \\
not indicate optional inclusion as normal.
\end{flushright}

\begin{verbatim}
   <achieve_after_point> := <end> <node_number> 
                          | [ begin_of] self | [end_of] start
\end{verbatim}
\index{\M{condition\_statement}}
\index{\M{limited\_condition\_type}}
\index{\M{contributor\_entry}}
\index{\M{achieve\_after\_point}}
\index{{\bf achieve}}
\index{{\bf achieve ... after}}
\index{{\bf achieve ... after ... start}}
\index{{\bf achieve ... after ... self}}
\index{{\bf after ... start}}
\index{{\bf after ... self}}
\index{{\bf supervised}}
\index{{\bf unsupervised}}
\index{{\bf only\_use\_if}}
\index{{\bf only\_use\_for\_query}}


The following sections describe some of the parts of the {\bf
schema} statement in more detail. 

\subsubsection{General Notes}

In all cases where a value is allowed and no [ = \M{value} ] term is given
to accompany a \M{pattern} (e.g. in effects and conditions) then the
\M{value} defaults to that set in the {\sc tf} Compiler {\bf defaults}
{\bf value} statement.

Similarly if there is no explicit {\bf at} \M{node\_end} mentioned then the
relevant information (effect, condition, time window, resources, etc.) is
given with respect to the overall schema network (i.e. the equivalent of {\bf
at self} with a {\bf begin\_of} or {\bf end\_of} keyword).
With normal {\sc tf} Compiler defaults for the end to use for effects and
conditions, this implies that the effect is asserted at the {\bf end\_of} of
the {\em last} node of the expansion, whereas {\bf conditions}, {\bf
time\_windows} and {\bf resources} are assumed to take effect from the {\bf
begin\_of} of the {\em first} node of the expansion.  This is the case for
single and multiple node networks.

\subsubsection{Schema}
\index{schema}
\index{{\bf schema}}
\index{{\bf meta\_schema}}
\index{{\bf process\_schema}}
\index{{\bf meta\_process\_schemas}}
\index{schema, process}
\index{schema, meta}
\index{meta-schema}
\index{process schema}

{\bf meta\_schema}s, {\bf process\_schema}s and {\bf
meta\_process\_schema}s are not currently supported by the O-Plan {\sc
tf} Compiler, but our intention is to provide these in future. 

A {\bf [meta\_][process\_]schema} may be an instance of an existing {\bf
meta\_schema}.  The effect is as if all the components of the meta\_schema
were already available to the new schema being defined.  A meta\_schema can
have any components that a schema can, except for nodes and orderings on these
nodes.  The {\bf meta\_} capability is entirely implemented by
the {\sc tf} Compiler and involves the equivalent of a textual
addition of the components provided in a {\bf meta\_schema} into
the schema which is declared to be an {\bf instance\_of} the meta-schema.

\subsubsection{Vars, Local\_vars and Vars\_relations}
\index{variables}
\index{{\bf vars}}
Schemas may introduce variables via the {\bf vars} statement, and can appear
in any {\tt \M{pattern}} or {\tt \M{pattern$>=<$value}} component within
the rest of the schema.

When declared, variables may be unrestricted (the value {\bf undef} -- the
default) or given some restriction (e.g.  ?\{{\bf not} table\} or ?\{{\bf
type} block\}).  A type is required for any variable which will not be bound
after schema selection by the planner.  A schema may insist on a full binding
for a variable before being used for an expansion (using the {\bf ?\{bound\}}
match specification).

\index{{\bf local\_vars}}
\index{{\bf undef}}
\index{schemas, public information}
\index{schemas, private information}
{\bf local\_vars} (like {\bf vars}) Variables which are declared in the vars
and {\bf local\_vars} sections are handled similarly and indeed there is
nothing to stop the {\sc tf} writer declaring all variables in the {\bf vars}
section.  However, by splitting the declarations a clearer distinction is made
within the schema between the {\em public} and {\em private} parts of the
schema.

\index{vars relations}
\index{{\bf vars\_relations}} 
\index{{\bf $=$}}
\index{{\bf $/=$}}
The {\bf vars\_relations} statement specifes that two variables within
the schema have a specified relationship.  At present this can be {\bf
=} or {\bf $/=$}. 

\subsubsection{Expands and Only\_Use\_For\_ ...}
\index{expands}
\index{only\_use\_for\_effects}
\index{{\bf expands}}
\index{{\bf only\_use\_for\_effects}}

The {\bf expands} \M{pattern} phrase is only present if the schema or
process schema refines an action or event (respectively) to a lower level of
detail -- this is essential in the case of a primitive schema description.  If
there are no {\bf only\_use\_for\_...}s mentioned then it is assumed that
the schema can only be used for expansion.  This implies then that at least
one of the {\bf expands} or {\bf only\_use\_for\_...} statements must be
present in any schema.

{\bf only\_use\_for\_effects} allows selection of a schema to achieve a
required condition in the plan.  The {\bf only\_use\_for\_effects} are
asserted into the {\sc tome} like normal {\bf effects}.  The normal {\bf
effects} in the schema are not used in the lookup of suitable schema
expansions and they should not repeat or contradict {\bf
only\_use\_for\_effects} statements used earlier in the same schema.
\index{{\bf only\_use\_for\_effects}}
\index{{\bf effects}}

{\bf only\_use\_for\_resources} allows
selection of a schema to change resource availability in a plan --
normally through the production of resources. 
\index{{\bf only\_use\_for\_resources}}

{\bf only\_use\_for\_authority} allows
selection of a schema to change authority levels for planning or
execution.
\index{{\bf only\_use\_for\_authority}}

\subsubsection{Nodes, Orderings -- Expansions or Decompositions}
\index{nodes}
\index{orderings}
\index{expansion}
\index{decomposition}

The {\em expansion} or {\em decomposition} of a schema is defined by the {\bf
nodes} list and the associated {\bf orderings}.

\index{nodes}
\index{{\bf nodes}}
\index{{\bf start}}
\index{{\bf finish}}
\index{{\bf event}}
\index{{\bf dummy}}
Nodes may have type {\bf action} or {\bf dummy}.  \M{node\_type}s {\bf
start} and  entry for each member of the set and for iterate will establish a{\bf finish} are simply special forms of the {\bf dummy} node type
and are only found in task\_schemas. They may be introduced automatically by
the {\sc tf} Compiler or User Interface rather than explicitly included by the
user.  All {\bf dummy} node types are defined to have a duration of 0 time
units, i.e., their {\bf begin\_of} time is identical to their {\bf end\_of}
time.

\index{orderings}
\index{{\bf orderings}} 
\index{delays} 
\index{time delays}
\index{\M{delay\_spec}}
The {\bf orderings} on the nodes specified in the schema network may
include a \M{delay\_spec} between the two \M{node\_end}s.  This may
be set to 0 for {\em consecutive} actions or any numerical expression
specifying a delay $>$= 0.  This expression may be an evaluable
expression which may or may not contain variables. 

\index{\M{order\_block}}
\index{{\bf sequential}}
\index{{\bf parallel}}
An \M{order\_block} allows ordering constraints to be specified along with
the nodes.  A {\bf sequential} block specifies that the nodes and blocks
it contains must be linked to enforce the order in which they are
listed.  A {\bf parallel} block adds no restrictions of its own but allows
nodes to be grouped within a {\bf sequential} block.

\label{iteration}
\index{foreach}
\index{iterate}
\index{{\bf foreach}}
\index{{\bf iterate}}
\index{{\bf from}}
\index{{\bf over}}
\index{{\bf event}} 
The {\bf foreach} or {\bf iterate} option may be given for node types
{\bf action} and {\bf event} along with the associated {\bf from}
\M{variable\_name} {\bf over} \M{iteration\_set} phrase (which is only
allowed in this context). This indicates that the node information
should be replicated for each member of the set and the resulting
nodes placed in parallel ({\bf foreach}) or in a sequence ({\bf
iterate}).  If there is more than one iterator, connected by {\bf
and}, nodes are generated from the Cartesian product of the sets.

Although the \M{iteration\_set} is defined as a \M{pattern\_component},
which might be a single variable, it should be instantiated to a list
of items, as if the syntax had been \M{general\_set}.

For both {\bf foreach} and {\bf iterate}, expansion will generate a
new node entry for each member of the set (or of the Cartesian
product).  For {\bf iterate}, there will additionaly be a sequential
ordering of the nodes.  An example is:

\begin{verbatim}
   N iterate action {fly_to ?way_point}
                    for ?way_point over ({100 50} {200 60} {150 40})
\end{verbatim}
on expansion this would be equivalent to:
\begin{verbatim}
     nodes N action {fly_to {100 50}},
           X action {fly_to {200 60}},
           Y action {fly_to {150 40}};
     orderings N ---> X,  X ---> Y;
\end{verbatim}

Any orderings on the original node number N are applied to the
{\bf begin\_of} the first node in the sequence and the {\bf end\_of} the
last node in the sequence.

A {\bf foreach} is identical except that no orderings are introduced.
This means that any orderings given on the {\bf foreach} node number may
cause {\bf dummy} nodes to be inserted to preserve the intended orderings.
For example,

\begin{verbatim}
   N foreach action {counter_problem ?problem}
                    for ?problem over (issue_1 issue_2)
\end{verbatim}
on expansion this would be equivalent to:
\begin{verbatim}
     nodes N dummy,
           X dummy,
           Y action {counter_problem issue_1},
           Z action {counter_problem issue_2},
     orderings N ---> Y, N ---> Z,
               Y ---> X, Z ---> X;
\end{verbatim}

Note that the expansion for {\bf iterate} and {\bf foreach} is done
while palnning and ({\em not} at {\sc tf} compile-time).  Hence, it is
possible for the iteration set to be something that could not be
determined at compile-time.  This llows, as examples, the set
to be read from an external source of information (such as an external
trajectory computation routine) or instantiated through variables set
elsewhere in planning.

\subsubsection{Conditions}
 
Typed conditions are used within O-Plan to aid the planning process.

A {\bf supervised} condition is satisfied from an earlier point in that
schema and must be further qualified by the [ {\bf from}
\M{contributor\_entry} ] which identifies the point(s) at which the
contributing effects are made available. 
\index{{\bf supervised}} 

\subsubsection{Conditions - Compute}
\index{compute condition}
\index{conditions, compute}
\index{{\bf compute}}

{\bf compute} conditions provide the external systems interface to O-Plan.
The left hand side of a {\bf compute} condition has the form:

\begin{verbatim}
   { <function_name> [ <parameter> ... ] }
\end{verbatim}

where each parameter can have the same recursive form.  The parameters
will typically be (or at least include) schema variables which will normally
be instantiated before use.

The \M{general\_pattern} must match against the result for the {\bf compute}
condition evaluation to succeed.  Further variable binding can occur during
this match.

The optional {\bf depends\_on} phrase, which is only
given for a compute condition, has one or more \M{compute\_dependency}
clauses of the form:
\index{{\bf depends\_on}} 

\begin{verbatim}
   <pattern> [ = <value> ] [from <variable_name> ]
\end{verbatim}

and these are returned to record the dependencies that must continue to
be maintained for the results to be valid.  If the {\bf from} phrase is
specified, the particular statement must be maintained from (one of the
list of) contributor(s) returned to the \M{variable}.

For example, the following {\bf compute} condition would check if
one block was {\em over} another block by (recursively) checking
individual statements of form \{on \_ \_\}.

\begin{verbatim}
   compute {over ?x ?z}=true at end_of 3
              depends_on {on ?x ?y}=true from ?contrib-1
                         {over ?y ?z}=true from ?contrib-2
\end{verbatim}

If there is no
{\bf from} phrase then it is assumed that the contributor is the initial
node of the plan, that is from the initial state.  This also works for
the case when the contributor is an {\bf always} fact, however, it is
better not to give a {\bf depends\_on} term if a dependency is related
to a fact which can never be invalidated.  Dependencies must be
maintained {\em to} the \M{node\_end} specified in the {\bf at} phrase
for the condition.  As with {\bf only\_use\_for\_query} type conditions,
dependencies are maintained but are considered ``re-establishable'' by
recomputing the {\bf compute} function.  This will result in the
retraction of the original {\sc gost} entry and the establishment of a
new one. 
\index{{\bf from}} 
\index{{\bf always}} 

{\bf compute} type conditions containing variables are
evaluated as and when the appropriate variable bindings are found. 

\subsubsection{Notepad}
\index{{\bf notepad}}
\index{{\bf at notepad}}
\index{notepad}
\index{notes}

The {\bf notepad} can be used as an {\bf at} qualifier to keep effects which
are related to the overall plan but are not associated with any specific plan
item (such as an action) in the plan.  {\bf notepad} effects are known as {\em
notes}.  Conditions can be stated with respect to the {\bf notepad} effects
using {\bf at notepad}.

\subsubsection{Authority}
\index{authority}
\index{{\bf authority}}

Not in use in the current version of O-Plan.

\subsubsection{Time Windows}
\index{time windows}
\index{{\bf time\_windows}}
\index{{\bf duration}}
\index{{\bf delay\_between}} 

It is possible to specify three types of time windows in schemas.  One is
normally used to give a metric time value (e.g.  a specific time or date) or a
time relationship to a specific time point.  This is done with the {\bf at}
option.  The second is used to specify the {\bf duration}
of a node (normally an action node type) in the expansion.  The third allows
time distances between two points to be specified (normally for a {\bf
delay\_between} between the \M{end}s of one node
and another.  This {\bf delay\_between} form is exactly equivalent to the
specification of a \M{node\_end} --- \M{delay\_spec} ---$>$
\M{node\_end} in the orderings statement.  The {\sc tf} writer is free to
use whichever form is most convenient.  If {\em both} forms are used the
specifications must be compatible (but not necessarily equal).

\subsubsection{Other Constraints}
\index{other constraints}
\index{{\bf other\_constraints}}

The O-Plan architecture allows for the replacement of the standard
constraint managers for time and resource management with
more capable constraint managers from other sources, and also
for the addition of constraint managers for new constraint types.

If a standard manager is replaced, then the more capable manager may
be able to handle richer constraints as well as managing the standard
time and resource information given in {\sc tf}.  Since these richer
constraints may not fit the standard time and resource syntax, they
can be specified in an \M{other\_constraints\_clause}.  New types
of constraints may also be specified in that way.  The {\sc tf}
compiler provides a way for the syntax of \M{other\_constraints\_clause}
to be extended to include these new syntaxes.

O-Plan provides this feature as a way to allow for extension of the {\sc
tf} Compiler by a systems integrator and to act as a demonstration of how to
pass information between O-Plan and its constraint managers.  Any {\bf
other\_constraints} which are rejected by the relevant constraint manager
which is installed in O-Plan will be treated as a {\bf notepad} effect and
will thus appear there as a {\bf note}.
\index{notepad}
\index{{\bf notepad}}
\index{note}
\index{note of other constraints}
\index{\{\bf note}}

% /\/ Will it really be a note?

\subsection{Primitive Actions}
\index{primitive actions}
\index{actions, primitive}
\index{schemas, primitive}

A definition of a {\em Primitive Action} can be given by providing a
schema with an {\bf expands} statement and no {\em expansion} (i.e.  no
{\bf nodes} and associated {\bf orderings}).  An action pattern
introduced by a higher level schema is then considered as {\em
primitive} and not expandable further if its action \M{pattern}
matches such an {\bf expands} entry.  A {\em Primitive Action } schema
can still have other schema related information such as {\bf vars}, {\bf
conditions}, {\bf (only\_use\_for\_)effects}, {\bf time\_windows} and
{\bf (only\_use\_for\_)resource} statements. 
\index{{\bf expands}} 
\index{{\bf nodes}} 
\index{{\bf orderings}}

\subsection{Initial Information for Plan Generation}
\index{initial information}

An initial world description and other initialisation for tasks may be
provided through the following {\sc tf} forms:

\begin{verbatim}
   initially <pattern> [ = <value> ] ,
             ...  ;

   initial_resources  <resource_usage_spec> ,
                      ...  ;

   initial_authority <authority_statement> ,
                     ... ;

   initial_time  <time_spec> ;
\end{verbatim}
\index{{\bf initially}}
\index{{\bf initial\_resources}}
\index{{\bf initial\_authority}}
\index{{\bf initial\_time}}

Unlike all other {\sc tf} forms, these initial statements are not additive or
incremental to the information from previous forms.  They represent the total
information to be used in the specification of any following task.  It is
possible to select an empty set of initial information by use of the
following:

\begin{verbatim}
   initially;            ;;; no initial world model statements
   initial_resources;    ;;; no initial resource availability
   initial_authority;    ;;; no initial authority (see note)
   initial_time;         ;;; reset initial time to "zero" time
\end{verbatim}

The initial information given is used for any following task that is provided.
A change of the initial information does not alter the initial
information which may have been used for earlier provided task statements.

Giving an empty {\bf initial\_authority} would not be very useful as it would
not allow any planning to take place.  The {\sc tf} Compiler will issue the
warning ``no authority to plan being given -- check that this is intended''.
A more useful ``baseline'' initial authority would be to allow planning to the
most primitive level of activity available, but not to go on and immediately
allow execution without further authorisation.  That is:

\begin{verbatim}
   initial_authority provides {authority plan all} = inf,
                     provides {authority execute all} = no;
\end{verbatim}

This is the default on O-Plan initiatisation if no explicit {\bf
initial\_authority} statement has been given.

\subsection{Task Schemas}
\index{task schemas}
\index{schemas, task}

Task schemas are the means of (uniformly) specifying particular tasks for plan
generation. Within these schemas it is possible to fully specify separate
resource limits, initial time windows and initial world model states for each
of the possibly many separate alternative task schemas at the top level.

Schemas whose name starts with the keyword {\bf task\_} are selected by the
O-Plan Task Assignment user menu system to present to the user as alternative
tasks to select from.  Once one is selected, planning is initiated by posting
an initial plan based on it.

A task schema uses the information from the last provided {\bf initially},
{\bf initial\_resources}, {\bf initial\_authority} and {\bf initial\_time}
{\sc tf} forms as a basis.  Additional effects, resources and authorities or a
different time specification can then be provided and will add to those
provided previously.  Task schemas inherit these initial statements in a
manner similar to the schema/meta\_schema relationships.
Note that in the case of initial authorities, if none are given in an
{\bf initial\_authorities} statement, then the default is to allow planning
to any level, but not to allow execution (see {\bf initial\_authority}
definition section).

\index{{\bf initially}}
\index{{\bf initial\_resources}}
\index{{\bf initial\_authority}}
\index{{\bf initial\_time}}

A task schema has the following general form:

\begin{verbatim}
   schema task_<name>;
      only_use_for_effects {task_achieved} = true at end_of 2;
      nodes   1   start,
              2   finish;
      orderings end_of 1 ---> begin_of 2;
      ;;; the user may provide additional nodes, orderings, conditions, etc
      time_windows  <initial_time> at 1;
      resources     <initial_resources> at 1;
      authority     <initial_authorities> at 1;
      effects       <effects from initially statement> at 1;
   end_schema ;
\end{verbatim}

The current relevant {\sc tf} Compiler {\bf defaults} node ends are
used for the {\bf at} 1 ({\bf start} node) position for initial
effects, authority, resources and time.  Recall that a {\bf start}
node is a {\bf dummy} node and hence has zero duration.  This means
that all initial information will apply at the same plan-relative time
whichever end is the current default.

For convenience, a {\sc tf} form is provided to ease the specification of
tasks.  The basic form is:

\begin{verbatim}
   task <name>;
      ;;; the user may provide nodes, orderings, conditions, etc.
   end_task;
\end{verbatim}
\index{{\bf task\_}}

The {\sc tf} Compiler adds the following to the entries provided by a {\sc tf}
writer in such a {\bf task}:

\begin{verbatim}
      time_windows  <initial_time> at 1;
      resources     <initial_resources> at 1;
      authority     <initial_authority> at 1;
      effects       <effects from initially statement> at 1;
\end{verbatim}

In all task schemas, the user must ensure that the {\bf start} node
is node number 1 and that the {\bf finish} node is node number 2.
These must be ordered with respect to each other and any other user provided
nodes such that provide for a unique start and finish node for the
task expansion.
\index{{\bf start}}
\index{{\bf finish}}

\opsection{TF Compiler}
\index{TF compiler}

The O-Plan {\sc tf} Compiler converts the Task Formalism language
(coming from a file or from typed input from a user) into the
internal Domain Information used by the O-Plan planner.  The compiler
can be run incrementally and will add to or modify the existing Domain
Information available to the planner.

Where a {\sc tf} form is specified which has the same name as a form which
already exists (say a schema or a type with the same name) or where a
statement which is not additive is given (i.e.  the {\bf initially}, {\bf
initial\_resources} and {\bf initial\_time} statements) then these override
any previous entry in the domain information.
\index{{\bf initially}}
\index{{\bf initial\_resources}}
\index{{\bf initial\_time}}

It is anticipated that facilities to change previously
specified {\sc tf} forms will be provided, as well as the current facility
to completely replace an old form or add to the forms already present.

The {\bf defaults} statement in {\sc tf} is used to
inform the planner of the defaults it should use in its operation. 
The compiler uses the given defaults or those provided in the last {\bf
defaults} statement until such time as a new domain is
selected (normally by re-initialising the planner or calling the {\bf
new\_domain} O-Plan command).

The {\sc tf} Compiler performs a number of {\sc tf } {\em form expansion}
roles.  Two examples are for the incorporation of the current {\bf initially},
{\bf initial\_resources} and {\bf initial\_time} statements into a {\bf
task\_schema} and the incorporation of the text of a {\bf
meta\_[process\_]schema} into a schema shown as an {\bf instance\_of} the
meta-schema.

\index{{\bf defaults}}
\index{{\bf new\_domain}}

\opsection{O-Plan Commands}
\index{commands}

The following are commands which can be used to control the top level of
O-Plan:

% /\/ False, false, false!

\begin{description}

\item[oplan]
\index{{\bf oplan}}
This command is the means of entry into the menu-driven O-Plan task
assignment interface which will be the normal method of interacting with and
controlling O-Plan.  It provides access to each of the commands below in a
convenient form.

\item[new\_domain]
\index{{\bf new\_domain}}
This instructs the Planner to clear all knowledge of previous problems worked
on during this current session.

\item[tf \M{domain\_name}]
\index{{\bf tf \M{domain\_name}}}
This action loads in the {\sc tf} description from
the file associated with \M{domain\_name}. This file name is derived
directly from the \M{domain\_name}.  It will incrementally add
to any previous {\sc tf} descriptions given since the last
{\bf new\_domain} command.

\item[plan \M{task\_schema\_name}]
Planning starts with the loading onto the pending task agenda of the task
schema with name {\bf task\_\M{task\_schema\_name}} describing the action(s)
to be expanded, or condition(s) to be achieved.  An error will be signaled if
a task schema with the given name has not been provided previously.
\index{{\bf plan \M{task\_schema\_name}}}

\item[plan\_view]
\index{{\bf plan\_view}}
This command provides a menu of plan state browsing facilities to the user.
Plan browsing is possible at any time, whether or not a plan has already been
successfully generated.

\item[world\_view]
\index{{\bf world\_view}}
This command provides a menu to a facility which can provide descriptions of
the state of the world model at nominated points in the plan.  Plan simulation
is possible at any time, whether or not a plan has already been successfully
generated.

\item[replan]
\index{{\bf replan}}
Having already generated a successful solution, {\bf replan} looks for a
further solution amongst the alternatives remaining.

\item[execute]
\index{{\bf execute}}
This command instructs the planner to pass the plan for execution to the
execution system.  An error will be signaled if the execution system is not
available in the O-Plan system running.  In the current implementation.
execute may only be used on a valid fully generated plan.

\item[quit]
\index{{\bf quit}}
To exit from the O-Plan system.
\end{description}

\opsection{Predefined Compute \M{function names}}
\label{predefined-compute-functions}
O-Plan provides a number of predefined compute functions.  Each
has a name starting with {\bf fn\_}.  The predefined
boolean predicates return values ``{\bf true}'' or ``{\bf false}''.  This
simplifies the writing of compute conditions in schemas.  E.g.
\index{compute functions, predefined functions}
\index{conditions, predefined compute functions}
\index{{\bf fn\_}}
\index{{\bf true}}
\index{{\bf false}}

\begin{verbatim}
     condition compute true = {fn_neq ?filter green}
\end{verbatim}

\begin{itemize}

\item {\bf fn\_ask} ( \M{prompt} [ , \M{response\_list} ] ) \newline
\M{response\_list} may be {\bf undef} for any answer.
This is the default if no \M{response\_list} is given.  The first answer in
any list is the default if the user types return.  If the user types return
and the response list is undef, then the user is asked the question again
after a suitable message is given about their being no defaults.
\index{{\bf fn\_ask}}

\item {\bf fn\_cond} ( \M{boolean} , \M{true\_result} ,
\M{false\_result} ) \newline
Provides a conditional answer which depends on the boolean parameter.
\index{{\bf fn\_cond}}

\item {\bf fn\_or} ( \M{boolean} , \M{boolean} ) \newline
This is a function to compute the ``or'' of the arguments.
\index{{\bf fn\_or}}

\item {\bf fn\_and} ( \M{boolean} , \M{boolean} ) \newline
This is a function to compute the ``and'' of the arguments.
\index{{\bf fn\_and}}

\item {\bf fn\_eq} ( \M{parameter} , \M{parameter} ) \newline
Checks if the parameters are equal.
\index{{\bf eq}}
\index{{\bf fn\_eq}}

\item {\bf fn\_neq} ( \M{parameter} , \M{parameter} ) \newline
Checks that the parameters are not equal.
\index{{\bf fn\_neq}}

\item {\bf fn\_leq} ( \M{parameter} , \M{parameter} ) \newline
Computes whether parameter 1 is less than or equal to parameter 2.
\index{{\bf fn\_leq}}

\item {\bf fn\_geq} ( \M{parameter} , \M{parameter} ) \newline
Computes whether parameter 1 is greater than or equal to parameter 2.
\index{{\bf fn\_geq}}

\end{itemize}

These are available as if the following {\bf compute\_conditions}
\index{{\bf compute\_conditions}} statement had been provided. 

\begin{verbatim}
   compute_condition {fn_ask ?? ?{or undef ?{type list}}} = ??,
        {fn_cond ?{or true false} ?? ??} = ??,
        {fn_or ?{or true false} ?{or true false}} = ?{or true false},
        {fn_and ?{or true false} ?{or true false}} = ?{or true false},
        {fn_eq ?? ??} = ?{or true false},
        {fn_neq ?? ??} = ?{or true false},
        {fn_leq ?{type number} ?{type number}} = ?{or true false},
        {fn_geq ?{type number} ?{type number}} = ?{or true false};
\end{verbatim}

Currently, all predefined compute functions are defined to require fully
instantiated parameters (i.e., have an additional constraint of ?\{{\bf
bound}\}) and will return a single result without any dependency information.
\index{{\bf bound}}
\index{{\bf ?}\{{\bf bound}\}}

\opsection{Guidelines for Writing TF}
\index{TF guidelines}

It is intended that a guide to how to approach the modelling of a domain in
{\sc tf} will be provided in due course.  For the moment, this section will
collect together detailed advice on the use of various {\sc tf} forms and
experience gained, or common pitfalls encountered, in coding specific domains.

We suggest below an ordered set of steps that a {\sc tf} domain writer may
go through to ensure a good result.  We rather grandly call this the Task
Formalism Method ({\sc tfm}) to reflect our desire to gather experience of
writing {\sc tf} to improve the method itself and to provide future {\sc tf}
Compiler intelligent support and user guidance.
\index{TFM (Task Formalism Method)}
\index{Task Formalism Method ({\sc tfm})}

\subsection{Scope the Domain and Initial Analysis}
\index{TF guidelines, scope the domain}
\index{TF guidelines, initial analysis}

Like any data analysis task, it is important to plan carefully how a domain
description is to be provided in {\sc tf} to O-Plan.  It is all too easy to
let a domain description grow in a haphazard and inconsistent way.  The
present {\sc tf} compiler and user interface support aids do not offer the
{\sc tf} writer much support apart from error-checking.

It is useful to view one user role in writing a domain description in {\sc tf}
as being that of {\em Domain Expert}.  This user will decide on the scope of
the domain and introduce the top level of description.  It is then possible to
``fill-in'' the details by considering other information given to describe a
domain in {\sc tf} as being provided by one or more {\em Domain Specialists}.
\index{domain expert}
\index{domain specialist}

\subsection{Action Expansion or ``Goal'' Achievement?}
\index{TF guidelines, action expansion}
\index{TF guidelines, goal achievement}

Two different approaches are possible to model domains.  A hierarchical {\em
action expansion} approach is primarily supported by O-Plan.  However, it is
also possible to state required conditions on the state of the world at
certain points -- a {\em goal achievement} approach.  This is also supported by
O-Plan.  The approaches can be mixed in any way convenient to model the
domain.  However, it is useful to consider which is to be the main approach
during the initial domain modelling exercise.

\subsection{Levels of Modelling}
\index{TF guidelines, levels of modelling}
\index{TF guidelines, task formalism method}

It is all too easy to introduce actions, events, effects and resources and
state conditions or use resources at different levels, making the modelling
awkward and unnatural.  This is sometimes referred to as ``hierarchical
promiscuity'' or ``level promiscuity''.  This will almost certainly lead to
the inability to make effective use of search restriction domain information
such as condition and resource types.
\index{hierarchical promiscuity}
\index{level promiscuity}

Actions and the effects they introduce are at a particular domain modelling
level.  Higher levels are more abstract, lower levels are more detailed.  In
some cases, certain (external) types of conditions can only be stated on
effects introduced at a domain modelling level which is at a higher or the
same modelling level as the condition.  In other cases, certain (internal)
types of conditions can only be stated on effects introduced at a domain
modelling level which is at the same or a lower modelling level as the
condition.

In anything other than trivial domains, it is essential to have a plan based
on an initial analysis of the structure of the problem to decide on what
actions, events, effects and resources will be modelled at progressively more
detailed levels.

Assuming an action expansion approach, we suggest the following method as
being suitable for O-Plan; it provides most effectively for hierarchical
expansion of activity based plans with associated condition/effect, resource
and time modelling.  The steps may not be able to be followed in a total
order, but the items below may act as a useful checklist.  If a goal
achievement approach is being used primarily, then the ordering of the steps
may place an earlier emphasis on those steps related to condition (especially
the {\bf achieve} type) and effect modelling.

\begin{enumerate}
\item
Identify the main actions (and events) that will appear at the top level of a
task or plan.  This is the {\em task} or top level.

\item
Gradually work down through progressively lower levels of detail and
try to identify the more detailed actions (and events) to be introduced.
It is best if each level introduced has some real meaning to those
involved in planning in the real world.  Giving a ``name'' to each level
is a good discipline to ensure that the modelling levels will be useful.

\item
It is then useful to decide on what statements about the world (in the form of
effects) will be introduced and manipulated at the various levels by the
actions (and events) at each level.

\item
It is only after these steps have been taken that the conditions required
for each action (or event) need to be considered.  It is then possible to
ensure that these are introduced at levels at or below the level in which
the relevant effects are introduced.

Type information to restrict the usage of conditions to those that are
meaningful in the domain can now be added reliably.

\item
This can then be refined by considering the resources that are manipulated at
each level.

\item
Time restrictions and information can then be considered.

\end{enumerate}

\subsection{Writing a Schema -- the Schema Envelope}
\index{TF guidelines, writing a schema}
\index{TF guidelines, schema envelope}
\index{envelope of schema}
\index{schema envelope}

When writing a schema in {\sc tf} it is useful to view the schema as ``owned''
by some individual responsible for the activity being described.  That
individual describes one way in which the higher level activity can be
performed (or one way in which an indicated effect can be produced) in a plan.

Consider that there is a bounding box or {\em envelope} which at its outside
edge performs the activity or produces the desired effect(s).  It is possible
to state overall requirements for the schema on the envelope itself -- in terms
of required conditions, outer bounds on resource usage, outer limits of the
time the activity will take, etc.  This can be done by using the keywords {\bf
overall} or {\bf at self} in appropriate specifications of resources, time
windows and conditions.  Then, internally within the envelope, the details of
the way in which this is done can be described.

\subsection{Help for the TF Writer}
\index{TF guidelines, writer help}

These notes provide more detailed advice on the use of specific {\sc tf}
forms.

\begin{enumerate}

\item O-Plan (as its predecessors Nonlin and O-Plan1) is able to
effectively exploit effects and conditions expressed in a functional way.
Where non-boolean functional relationships exist in the domain, modelling them
directly can give great advantages in terms of search space restriction and
clarity of description over a more traditional modelling of facts in a
predicate logic form, as is common in other AI planners.  For example, rather
than use: {\tt \{switch 1 on\}=true} and {\tt \{switch 1 off\}=false} as two
separate statements it is better to use a functional form {\tt \{switch\_mode
1\}=on} and limit the value to be one of {\tt on} or {\tt off}.  This is even
more effective when the value can take a set of
bindings.  E.g. {\tt \{filter camera\_1\}=cyan} where the colour can be one
of a set of filter colours available.  Similarly some numerical functional
relationships are easily and efficiently expressed to the planner by this
mechanism such as {\tt \{age person\_2\}=37}.

\item To model the inclusion of conditional actions, it is necessary to
provide two schemas for an effect which represents that a condition is
satisfied or the action is included.  For example to conditionally include a
painting action only if the walls are not already painted, it is possible to
provide two schemas with {\bf only\_use\_for\_effect} (walls painted) say.  One
schema would have a set of conditions that checked if the walls were already
painted but would not introduce more actions.  The other would check that
walls were {\em not} already painted (via {\bf only\_use\_if} conditions) and
would introduce the action to paint the walls.  The conditional action can
then be introduced at any point in another schema by including an {\bf
achieve} condition for the {\bf only\_use\_for\_effect} ({walls painted} say).

\item To model the conditional or case-based inclusion of effects it is
necessary to provide several schemas with mutually exclusive condition or
variable restriction sets that differentiate when the effect should be
introduced and when it should not be.

\item Variables can be used in schemas, but it is a requirement that
the planner know the type of any partially instantiated variables left after
all selection conditions and constraints on the schema have been applied.
It is an additional constraint that this type must be enumerable (such as
a set type -- like a Pascal scalar, or an integer with a bounded range).
If you write a schema in such a way that there is any possibility of a
variable within the schema being left not fully bound, then it must have 
such a type added to its restrictions list.
\index{type, integer range}

\end{enumerate}

\subsection{Modelling Reusable Non-sharable Resources with Effects/Conditions}

Until such time as O-Plan supports a wider range of resource types, reusable
non-sharable resources can be modelled with conditions and effects.
Reusable non-sharable resources are fixed items such as keys or a specific
transport vehicle.

\begin{description}
\item[For Action Expansion]
In an action expansion modelling approach is being used, resource
allocation/deallocation can be done with effects, supervised and unsupervised
conditions at the outer envelope of the action.  The resources and their
status would usually be declared in the initial state for a task as follows:

\begin{verbatim} 
  effects {status workman_1} = unallocated at 1,
          {status workman_2} = unallocated at 1;
\end{verbatim}

An action which required such a resource would have conditions and effects
such as:

\begin{verbatim} 
  condition unsupervised {status ?workman} = unallocated at begin_of self,
            supervised {status ?workman} = allocated_to_XX
                                     at end_of self from begin_of self;
  effects   {status ?workman} = allocated_to_XX at begin_of self,
            {status ?workman} = unallocated at end_of self;
\end{verbatim} 

The {\tt allocated\_to\_XX} is qualified by the purpose of the allocation
({\tt XX}) to ensure that other potential parallel actions do not mistake the
allocation of the resource as being related to their different purpose.

The allocation of the resource can be more precise than the outer envelope of
the whole action ({\bf at self}) if the range required is known to be less.
The interval between the resource becoming available and it being released
will be protected by the {\bf supervised} {\sc gost} entry.

The use of a {\bf unsupervised} condition type as opposed to an {\bf
only\_use\_for\_query} will greatly reduce the size of the search space since
it leaves scheduling of the resources until late in planning (at the expense
of possible failure to resource a given plan at this late stage).  For
example, in a problem of allocating 4 resources to two activities using {\bf
unsupervised} as opposed to {\bf only\_use\_for\_query} the number of
planning cycles was reduced from 839 to 38 in a specific domain.

\item[For Goal Achievement]
If using a goal achievement approach (i.e. {\bf achieve} condition
satisfaction) most of the resource allocation can be done by the use of
{\tt achieve} conditions.  This leads to larger search spaces.

\end{description}

\opsection{Current Implementation}
\label{current-implementation}
\index{current implementation}

\subsection{Unsupported Features}
\index{unsupported features}
\index{TF features, unsupported}
The following features are not supported by the current implementation
of O-Plan.  They have been shown in the {\sc tf} Manual as an indication
of how O-Plan is intended to develop.

\begin{enumerate}

\item \M{expression} is not supported in \M{time\_spec} and
\M{min\_max\_spec}.  Only a \M{number} may be given wherever
\M{expression} appears in the syntax.
\index{\M{expression}}

\item {\bf plan\_viewer}
and {\bf world\_viewer}
{\sc tf} forms are supported only as documentation at present.
Any specific plan viewer and
world viewer programs other than the default must be activated explicitly by
the user.
\index{{\bf plan\_viewer}}
\index{{\bf world\_viewer}}

Only the world viewer snapshot output facility is supported.

\item {\bf preferences} are not supported.  Schema preference ordering
is the same as the order of processing by the {\sc tf} compiler, modified
by a cost estimate.
\index{{\bf preferences}}
\index{{\bf prefer\_plans\_with}}
\index{{\bf prefer\_schemas}} 

\item Only the {\bf consumable\_strictly} resource class is supported. 
Consideration of the value of the different resource classes is still
necessary.
\index{{\bf consumable\_strictly}}

\item Only the {\bf count} resource type is supported.  Consideration of
the value of the different types is still necessary. 
\index{{\bf count}}

\item The {\bf default\_resources} statement is not supported.  The
value of this statement is under consideration. 
\index{{\bf default\_resources}} 

\item The {\bf domain\_rule} statement is not supported.  Also, O-Plan
does not use {\em Temporal Coherence} information to inform its search
choices. 
\index{{\bf domain\_rule}} 

\item The {\bf plan\_levels} statement is not supported.
\index{{\bf plan\_levels}}

\item Restricted {\bf compute} condition support is available.
The {\bf depends\_on} clause cannot be given, none of the
predefined compute functions (see \S\ref{predefined-compute-functions})
are available, and the {\bf compute\_condition} statement is 
largely ignored.  However, any Common Lisp function whose name
would count as a \M{name} can be called, and {\bf multiple\_answer}
is supported.  (At present, the {\bf compute\_condition} statement
is consulted only to see whether function are {\bf multiple\_answer}
or not.)  Moreover, provided that all the variables in the function
arguments are bound by the time the condition is evaluated during
schema selection, numeric computations may be freely performed.
(After that, numeric values of variables must be members of the
variable's type, and the only numeric types available are integer
ranges.)
\index{{\bf compute}} 
\index{{\bf compute\_condition}} 
\index{{\bf depends\_on}} 
\index{{\bf multiple\_answer}}
\index{type, integer range}

\item {\bf meta\_schemas} and {\bf process\_schemas}\index{{\bf
process\_schemas}} are not supported. 
\index{{\bf meta\_schemas}}

\item The {\bf event} node type is not supported.
\index{{\bf event}} 

\item The {\bf foreach} and {\bf iterate} node iteration is supported,
but the iteration set(s) must be fully instantiated by the time the
schema is selected.  This can usually be accomplished by using
{\bf only\_use\_if} or {\bf compute} conditions to bind the
variables in the \M{iteration\_set}(s).
\index{{\bf foreach}}
\index{{\bf iterate}}

Note that the expansion of {\bf foreach} and {\bf iterate} is not
exactly as described in section \ref{iteration}.  Instead a dummy
node is always created and all the generated nodes are put {\em between}
the two ends of the dummy.  This means that references to the node
number of the iteration can work unmodified (while in the documented
implementation some renumbering of references would be needed), which
significantly simplifies the implementation.  However, it leads us to
violate the rule that a dummy node always has zero duration.

\item The {\bf notepad} is not supported.
\index{notepad}
\index{{\bf notepad}}
\index{notes}

\item The \M{other\_constraint\_clause}, which provides a place for
new types of contraints managed by ``plug-in'' constraint managers
(including constraint managers external to O-Plan), is supported,
but the details are subject to revision and are not yet described
in this document.
\index{\M{other\_constraint\_clause}}

\item The {\bf initial\_authority} statement is not active at present.
Give the information directly in a {\bf task} schema.  However,
{\bf initially}, {\bf initial\_resources}, and {\bf initial\_time}
will work.
\index{{\bf task}} 
\index{{\bf initially}}
\index{{\bf initial\_resources}}
\index{{\bf initial\_authority}}
\index{{\bf initial\_time}}

\end{enumerate}

\subsection{Features Anticipated}
\index{TF features, anticipated}

There are a number of areas where extensions to {\sc tf} are anticipated in
future, but where detailed discussion of the form of the {\sc tf} statement
has not been decided. 

\begin{enumerate}

\item {\sc tf} has been designed to allow many compile time error
messages and warnings to be given to the {\sc tf} provider.  The
current system should detect most syntax errors and performs a
range of semantic checks.  However, more extensive checking is
planned.

\item It is anticipated that facilities to change previously
specified {\sc tf} forms will be provided, as well as the current facility
to completely replace an old form or add to the forms already present.

\item It is anticipated that considerable development of the {\bf
plan\_viewer} and {\bf world\_viewer} features will be undertaken.  In
particular the development of a query language to allow the viewers to
selectively interrogate the agent and plan state in O-Plan may be a focus for
future work.
\index{{\bf plan\_viewer}}
\index{{\bf world\_viewer}}

\item It is anticipated that the {\bf type} of a variable will
be extended to allow further numeric types.

\item It may be useful to require that a unique start and end node be provided
for any schema expansion given.  This would allow regular handling of plans
and schema expansions in the O-Plan system and in user interfaces.  If
necessary, the {\sc tf} Compiler could introduce new {\bf dummy} nodes to
ensure that a unique initial and final node in an expansion was available.
The {\sc tf} Compiler could renumber the nodes in the {\bf nodes} statement
where necessary to ensure that the unique initial node is the
\M{node\_number} 1 and the unique final node is the \M{node\_number} 2.
However, any such renumbering may spoil the user's view of node numbering and
naming for authority-related matters and for diagnosis of problems.

\item It is anticipated that an iteration facility will be allowed in a
\M{resource\_usage\_spec}.  This will allow an {\bf initial\_resources}
declaration or a schema {\bf only\_use\_for\_resources} or {\bf resources}
clause to give repetitive delivery conditions for {\bf produces} statements,
for example.  The type of statement may have the form:
\begin{verbatim}
   <resource_usage_spec> [ per <time_unit> over_period <time_bounds_spec> ]
\end{verbatim}
\index{{\bf initial\_resources}}
\index{{\bf only\_use\_for\_resources}}
\index{{\bf resources}}
\index{{\bf produces}}
\index{{\bf per}}
\index{{\bf over\_period}}

The {\bf per/over\_period} qualifier will only be allowed for resources
belonging to appropriate resource classes.

\item A means to associate {\em calendars} with the time units in a
flexible way should be provided. 

\item A way to specify numerical comparisons rather more
directly than through {\bf compute} conditions is envisaged.

\item A way to give conditional conditions relating to {\bf compute} conditions
is envisaged.

% /\/: Um, what does _that_ mean?  Conditional conditions?

\item A method of specifying an open-ended set of effects instantiated
from a set of matching objects is being considered.  E.g.

\begin{verbatim}
   forall <variable_name> in <set_specification> <pattern> = <value>
\end{verbatim}

For example:

\begin{verbatim}
   forall ?sw in (switch1 switch2 switch3) {status ?sw} = off
   forall ?x in ?y {mode ?x} = nominal
\end{verbatim}

\begin{flushright}
Where {\tt ?y} is set elsewhere
\end{flushright}

There may be a need to have similar set-based conditions, or to properly
manage ``for all'' conditions rather than ``there exists'' conditions as
currently supported.

\item It is anticipated that more
comprehensive handling and matching for sets will be added in future.

\item Consideration may be given to allow restriction of the schemas
which may be tried to expand an {\bf action} or {\bf
event} node or to satisfy an {\bf achieve}
condition.  This would be done by allowing \M{schema}s to be
provided as {\em advice} which would be used instead of a general lookup
for matching schemas. 

\item Consideration may be given to an ability to specify ordering links
with respect to a sub-node of a nominated schema which expands an {\bf
action} or {\bf event} type node, i.e.,
{\bf orderings} K.L ---$>$ M.N.  This could be useful where schema expansion
nodes at the lower level represent for example {\em phases} of some
activity which are to be referred to from levels above.

\item Consideration will be given to the inclusion of a new node type
which would allow an action to be considered primitive for plan generation
purposes, but which could be marked as subsequently expandable in the normal
way.  Such a node type was included in later versions on Nonlin (called a {\bf
query} node type) to allow for actions which depended on inspections or tests.
The ideas was that if the test failed, that normal expansion through the use
of suitable recovery or repair actions was then possible.
\index{{\bf query}}

\item It may be useful to provide a facility to insist that a variable
be fully instantiated during the course of making a schema expansion (this may
force the binding of the variable during the expansion process if this does
not occur due to other conditions restricting the variable to one object).
This is different to the use of the ?\{{\bf bound}\} match restriction, which
insists that the variable is bound when a schema is first selected from the
pattern being expanded or the effect, resource or authority required.

\end{enumerate}

\subsection{Features Under Review}
\index{TF features, under review}

O-Plan is a research prototype and the Task Formalism ({\sc tf}) language
is itself undergoing changes as research ideas are clarified.  Any user
of O-Plan and {\sc tf} should note that the O-Plan team, AIAI and
the University of Edinburgh make no warranty that any {\sc tf}
statement form will be supported in future releases.
\index{TF, no warranty}

There are a number of areas where extensions to {\sc tf} are anticipated in
future, but where detailed discussion of the form of the {\sc tf} statement
has not been decided. 

\begin{enumerate}

\item At present it is anticipated that normal (action) schema
node lists will not contain events, and that process schema node
lists will not contain actions.  Task schema node lists will be
allowed to contain both.  However, further consideration and trial coding of
domains is required to clarify this proposed restriction.

\item The {\bf default\_resources} statement is under consideration
for removal and is not supported by the current release of O-Plan.  Another
possibility is the removal of the {\bf begin\_of} and the {\bf end\_of}
optional qualifiers in the {\bf default\_resources} statement and only to let
the statement define the resource specification limits between the beginning
and end of the action (i.e. the equivalent to stating a
\M{resource\_usage\_spec} {\bf at overall}).

\end{enumerate}

\newpage
\markboth{Index}{Index}

%** The following inputs the index file if it exists.  The @ option on
%** input allows this command to be ignored if the index file does not exist.
%** @ is a special character, so it must be set as a letter to allow @input

\makeatletter
\@input{tf-manual.ind}
\makeatother

\end{document}

.\" ------------------------- Change History ---------------------------------

.\" Local Variables:
.\" mode: latex
.\" version-command: "\\lastaltered"
.\" eval: (setq write-file-hooks (cons 'timestamp-for-latex write-file-hooks))
.\" End:


